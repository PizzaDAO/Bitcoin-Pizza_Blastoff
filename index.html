<!--
 * Bitcoin Pizza Blastoff
 * Created by CRXSS – https://crxss.xyz | https://linktr.ee/c_r_x_s_s
 * "Molto Bene" characters created by @infi1trate – https://x.com/infi1trate?s=21
 * Copyright (C) 2025 CRXSS
 
 * Inspired by PizzaDAO – https://globalpizza.party/
 *
 * This file is part of Bitcoin Pizza Blastoff.
 *
 * Bitcoin Pizza Blastoff is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * See the LICENSE file for details.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitcoin Pizza Blastoff</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      z-index: 100;
    }
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      display: none;
      z-index: 100;
      width: 80%;
      max-height: 85vh;
      overflow-y: auto;
      padding: 20px 15px;
      background-color: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      z-index: 100;
    }
    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-family: 'Arial', sans-serif;
      z-index: 200;
    }
    
    #start-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(247, 147, 26, 0.2) 0%, rgba(0, 0, 0, 0) 70%);
      z-index: -1;
    }
    
    #start-screen-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 95%;
      max-width: 900px;
      gap: 4px;
      overflow: hidden;
      animation: fadeIn 0.8s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    #pizzadao-logo {
      max-width: 53.2%;
      margin-bottom: 0;
      margin-top: 0;
      height: auto;
      filter: drop-shadow(0 0 8px rgba(247, 147, 26, 0.5));
    }
    
    #start-screen h1 {
      font-size: 2.8em;
      margin-bottom: 20px;
      color: #f7931a;
      text-shadow: 0 0 10px rgba(247, 147, 26, 0.5);
      letter-spacing: 1px;
      font-weight: bold;
    }

    #game-logo {
      width: 45%;
      max-width: 500px;
      height: auto;
      margin-top: 0;
      margin-bottom: 0;
      filter: drop-shadow(0 0 12px rgba(247, 147, 26, 0.6));
    }
    
    #start-screen p {
      font-size: 1.3em;
      margin: 0 0 4px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      gap: 5px;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      width: 90%;
      max-width: 450px;
    }
    
    .instruction-img {
      height: 40px;
      width: auto;
      vertical-align: middle;
      image-rendering: pixelated;
      margin: 0 5px;
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
    }
    
    #start-button {
      margin: 30px 0;
      padding: 12px 35px;
      font-size: 1.5em;
      background: linear-gradient(to bottom, #f7931a, #e67e22);
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 15px rgba(247, 147, 26, 0.4);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      font-weight: bold;
      letter-spacing: 1px;
    }
    
    #start-button:hover {
      background: linear-gradient(to bottom, #f9a638, #f7931a);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(247, 147, 26, 0.6);
    }
    
    #start-button:active {
      transform: translateY(1px);
      box-shadow: 0 2px 10px rgba(247, 147, 26, 0.4);
    }
    
    /* Pulsating effect for button */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    #start-button {
      animation: pulse 2s infinite;
    }
    
    #start-button:hover {
      animation: none;
    }
    
    /* Game credits */
    #game-credits {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 0.8em;
      color: rgba(255, 255, 255, 0.6);
      padding: 5px;
    }
    
    #retry-icons {
      display: flex;
      align-items: center;
    }
    .pizza-icon {
      width: 20px;
      height: 20px;
      margin-right: 5px;
      image-rendering: pixelated;
    }
    #respawn-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      display: none;
      z-index: 150;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
    }
    /* Audio unlock button style */
    #audio-unlock {
      position: fixed;
      top: 70px;
      right: 10px;
      background-color: rgba(0,0,0,0.7);
      color: white;
      border: 1px solid white;
      padding: 8px 12px;
      cursor: pointer;
      z-index: 300;
      font-family: Arial, sans-serif;
    }
    /* Test button style */
    #audio-test {
      display: none; /* Hide the test button */
    }
    /* Audio indicator style */
    #audio-indicator {
      display: none; /* Hide the audio indicator */
    }
    /* Toast notification for audio feedback */
    #audio-toast {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1000;
      font-family: Arial, sans-serif;
      display: none;
    }
    
    /* Crypto Winter Intro Overlay */
    #crypto-winter-intro {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #fafafa; /* Near white to match gauge background */
      z-index: 500;
      display: none;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    #crypto-winter-intro video {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 85%;
      height: 85%;
      object-fit: contain;
      pointer-events: none; /* Allow taps to pass through to overlay */
    }
    
    /* Hide default video controls on webkit browsers */
    #crypto-winter-intro video::-webkit-media-controls {
      display: none !important;
    }
    #crypto-winter-intro video::-webkit-media-controls-enclosure {
      display: none !important;
    }
    
    /* Full-width dark gradient at top for text contrast */
    #crypto-winter-gradient {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 280px;
      background: linear-gradient(180deg, rgba(30,40,50,0.95) 0%, rgba(30,40,50,0.7) 60%, transparent 100%);
      z-index: 501;
      pointer-events: none;
    }
    
    #crypto-winter-words {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: center;
      gap: 0px;
      z-index: 502;
      padding: 10px 10px;
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
    }
    
    #crypto-winter-words img {
      height: 165px;
      width: auto;
      object-fit: contain;
      opacity: 0;
      transform: scale(0.3) translateY(-30px);
      filter: drop-shadow(0 0 15px rgba(100, 200, 255, 0.9)) 
              drop-shadow(0 0 30px rgba(50, 150, 255, 0.6))
              drop-shadow(0 4px 8px rgba(0, 0, 0, 0.9));
    }
    
    #crypto-winter-words img.visible {
      opacity: 1;
      transform: scale(1) translateY(0);
      animation: wordGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes wordGlow {
      0% {
        filter: drop-shadow(0 0 15px rgba(100, 200, 255, 0.9)) 
                drop-shadow(0 0 30px rgba(50, 150, 255, 0.6))
                drop-shadow(0 4px 8px rgba(0, 0, 0, 0.9));
      }
      100% {
        filter: drop-shadow(0 0 25px rgba(150, 220, 255, 1)) 
                drop-shadow(0 0 50px rgba(100, 180, 255, 0.8))
                drop-shadow(0 4px 8px rgba(0, 0, 0, 0.9));
      }
    }
    
    /* Individual word sizing and animation - reduced 45% */
    #crypto-winter-words #word-welcome { 
      transition: opacity 0.5s ease-out, transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      height: 165px !important;
      max-height: 165px !important;
    }
    #crypto-winter-words #word-to { 
      transition: opacity 0.5s ease-out 0.15s, transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.15s;
      height: 120px !important;
      max-height: 120px !important;
    }
    #crypto-winter-words #word-crypto { 
      transition: opacity 0.5s ease-out 0.3s, transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s;
      height: 165px !important;
      max-height: 165px !important;
    }
    #crypto-winter-words #word-winter { 
      transition: opacity 0.5s ease-out 0.45s, transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.45s;
      height: 165px !important;
      max-height: 165px !important;
    }
    
    /* Intro Snow Effect */
    #intro-snow-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 503;
      pointer-events: none;
      overflow: hidden;
    }
    
    .intro-snowflake {
      position: absolute;
      top: -20px;
      background: white;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255,255,255,1), 0 0 15px rgba(200,230,255,0.8);
      animation: introSnowFall linear infinite;
      --drift: 30px;
    }
    
    @keyframes introSnowFall {
      0% {
        transform: translateY(-20px) translateX(0);
        opacity: 0;
      }
      5% {
        opacity: 1;
      }
      95% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(105vh) translateX(var(--drift));
        opacity: 0;
      }
    }
    
    @media (max-width: 768px) {
      #crypto-winter-words {
        flex-direction: column;
        gap: 0px;
        top: 5px;
        padding: 10px 15px;
      }
      #crypto-winter-words #word-welcome,
      #crypto-winter-words #word-crypto,
      #crypto-winter-words #word-winter {
        height: 66px !important;
        max-height: 66px !important;
      }
      #crypto-winter-words #word-to {
        height: 50px !important;
        max-height: 50px !important;
      }
      #crypto-winter-intro video {
        width: 90%;
        height: 40%;
        top: 55%;
        pointer-events: none;
      }
      #crypto-winter-gradient {
        height: 320px;
      }
    }
    
    #game-over img {
      max-width: 30%; /* Further reduced from 40% to 30% */
      margin-bottom: 5px;
    }
    
    #game-over p {
      margin: 5px 0; /* Reduced margin */
    }
    
    #leaderboard {
      margin: 8px auto; /* Reduced from 10px to 8px */
      width: 80%;
      color: white;
      text-align: center;
    }
    
    #leaderboard h2 {
      font-size: 1.2em; /* Reduced from 1.3em to 1.2em */
      margin-bottom: 3px; /* Reduced from 5px to 3px */
    }
    
    #leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    #leaderboard-list li {
      display: grid;
      grid-template-columns: 30px 1fr 80px;
      justify-content: space-between;
      text-align: left;
      padding: 2px 8px; /* Reduced from 3px 10px to 2px 8px */
      background-color: rgba(255, 255, 255, 0.1);
      margin-bottom: 2px; /* Reduced from 3px to 2px */
      border-radius: 3px;
    }
    
    #leaderboard-list .highlight {
      background-color: rgba(247, 147, 26, 0.5); /* Bitcoin orange with transparency */
      font-weight: bold;
    }
    
    #leaderboard-list .name {
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    #leaderboard-list .score {
      text-align: right;
    }
    
    #game-over button {
      margin: 8px 5px; /* Reduced from 10px to 8px */
      padding: 6px 12px; /* Slightly reduced from 8px 15px */
      font-size: 0.9em; /* Reduced from 1em to 0.9em */
      background-color: #f7931a; /* Bitcoin orange */
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    #game-over button:hover {
      background-color: #e67e22; /* Darker orange on hover */
    }

    #contributing-artists {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.2);
      text-align: center;
    }

    #contributing-artists h3 {
      color: #f7931a;
      font-size: 1em;
      margin-bottom: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    #contributing-artists .artist-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.78em;
      color: rgba(255,255,255,0.85);
    }

    #contributing-artists .artist-list {
      display: inline-block;
      text-align: left;
    }

    #contributing-artists .artist-entry {
      display: flex;
      align-items: center;
      padding: 4px 0;
    }

    #contributing-artists .level-name {
      color: rgba(255,255,255,0.5);
      width: 140px;
      text-align: right;
      padding-right: 10px;
    }

    #contributing-artists .artist-name {
      color: white;
      font-weight: bold;
      text-align: left;
      padding-left: 10px;
      border-left: 1px solid rgba(255,255,255,0.2);
    }

    #contributing-artists a {
      color: #f7931a;
      text-decoration: none;
    }

    #contributing-artists a:hover {
      text-decoration: underline;
    }

    #player-name-form {
      margin: 8px 0; /* Reduced from 10px to 8px */
    }
    
    #player-name-input {
      padding: 6px 10px;
      border: 2px solid #f7931a;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      width: 150px;
      margin-right: 5px;
      font-size: 14px;
    }
    
    #save-score-btn {
      padding: 6px 10px;
      background-color: #f7931a;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    #save-score-btn:hover {
      background-color: #e67e22;
    }
  </style>
  
  <!-- Simple audio element with no sources -->
  <audio id="gameAudio" preload="auto" style="display:none;"></audio>
  
  <!-- Add visual audio indicator - hidden now -->
  <div id="audio-indicator" style="display:none;"></div>
</head>
<body>
  <div id="ui">
    <div id="score">Score: 0</div>
    <div id="retry-container">
      <span>Lives: </span>
      <div id="retry-icons"></div>
  </div>
    <div id="laser-count">Laser Eyes: 0/3</div>
  </div>
  
  <div id="game-over">
    <img src="Assets/Visual/Game Over.png" alt="Game Over">
    <p>Score: <span id="final-score">0</span></p>
    
    <div id="player-name-form">
      <input type="text" id="player-name-input" placeholder="Your name" maxlength="15">
      <button id="save-score-btn">Save Score</button>
  </div>
    
    <div id="leaderboard">
      <h2>Highest Scores</h2>
      <ul id="leaderboard-list">
        <!-- Leaderboard entries will be added here dynamically -->
      </ul>
    </div>
    
    <button id="retry-button">Play Again</button>
    <button id="main-menu-button">Main Menu</button>
    
    <!-- Add creator credit with hyperlink -->
    <div style="margin-top: 15px; display: flex; justify-content: center; gap: 30px;">
      <a href="https://linktr.ee/c_r_x_s_s" target="_blank" style="display: inline-block;">
        <img src="Assets/Visual/created by CRXSS.png" alt="Created by CRXSS" style="max-width: 75px; height: auto;">
      </a>
      <a href="https://x.com/infi1trate?s=21" target="_blank" style="display: inline-block;">
        <img src="Assets/Visual/created by infi1trate.png" alt="Created by infi1trate" style="max-width: 75px; height: auto;">
      </a>
    </div>
    
    <div id="contributing-artists">
      <h3>Contributing Artists</h3>
      <div class="artist-list">
        <div class="artist-entry">
          <span class="level-name">Levels 1 - 3</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Jaipur</span><span class="artist-name"><a href="https://x.com/0xvishnuu?s=09" target="_blank">Vishnu</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Praha</span><span class="artist-name"><a href="https://x.com/113kw" target="_blank">113kw</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Vienna</span><span class="artist-name"><a href="https://x.com/CryptoWiener_" target="_blank">CryptoWiener</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Barcelona</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">New York</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Oslo</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Rio</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Tokyo</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Cemetery</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Moon</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
        <div class="artist-entry">
          <span class="level-name">Crypto Winter (hidden level)</span><span class="artist-name"><a href="https://crxss.xyz" target="_blank">CRXSS</a></span>
        </div>
      </div>
    </div>
  </div>
  <div id="respawn-message">
    <h2>You crashed!</h2>
    <p>Using 1 retry...</p>
    <p>Respawning in <span id="respawn-countdown">3</span></p>
  </div>
  <div id="instructions">
    Click, tap or press SPACE to fly up!
  </div>
  <div id="start-screen">
    <div id="start-screen-content">
      <img id="pizzadao-logo" src="Assets/Visual/pizzaDao-Logo.png" alt="pizzaDAO Logo">
      <img id="game-logo" src="Assets/Visual/logo.png" alt="Bitcoin Pizza Blastoff">
      <p>
        Tap, click, or press space bar to stay in the air
      </p>
      <p>
        Collect
        <img src="Assets/Visual/pizza slice.png" alt="Pizza" class="instruction-img">
        for more lives
      </p>
      <p>
        Collect
        <img src="Assets/Visual/bitcoin.png" alt="Bitcoin" class="instruction-img">
        for laser eyes to blast enemies!
      </p>
      <button id="start-button">Start Game</button>
      
      <!-- Add creator credit with hyperlink -->
      <div style="margin-top: 8px; margin-bottom: 0px; display: flex; justify-content: center; gap: 30px;">
        <a href="https://linktr.ee/c_r_x_s_s" target="_blank" style="display: inline-block;">
          <img src="Assets/Visual/created by CRXSS.png" alt="Created by CRXSS" style="max-width: 90px; height: auto;">
        </a>
        <a href="https://x.com/infi1trate?s=21" target="_blank" style="display: inline-block;">
          <img src="Assets/Visual/created by infi1trate.png" alt="Created by infi1trate" style="max-width: 90px; height: auto;">
        </a>
      </div>
    </div>
    
    <div id="game-credits">Bitcoin Pizza Blastoff • v2.0</div>
  </div>

  <!-- Remove test button -->
  <!-- <button id="audio-test">Test Audio</button> -->

  <div id="audio-toast">Molto Bene!</div>

  <!-- Crypto Winter Intro Overlay -->
  <div id="crypto-winter-intro">
    <video id="crypto-winter-video" src="Assets/Visual/fear_greed.mp4" muted playsinline webkit-playsinline></video>
    <div id="crypto-winter-gradient"></div>
    <div id="crypto-winter-words">
      <img src="Assets/Visual/welcome.png" alt="Welcome" id="word-welcome">
      <img src="Assets/Visual/to.png" alt="To" id="word-to">
      <img src="Assets/Visual/crypto.png" alt="Crypto" id="word-crypto">
      <img src="Assets/Visual/winter.png" alt="Winter" id="word-winter">
    </div>
    <div id="intro-snow-container"></div>
  </div>

  <!-- Add video element for ending video -->
  <video id="endingVideo" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 300; object-fit: contain; background-color: black;" src="Assets/Visual/To the Moon.mp4"></video>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(
      window.innerWidth / -2,
      window.innerWidth / 2,
      window.innerHeight / 2,
      window.innerHeight / -2,
      0.1,
      1000
    );
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Game state
    let gameActive = false;
    let animationFrameId = null; // Game animation loop ID
    let masterLoopId = null; // Menu/render loop ID
    let audioInitialized = false; // Track if audio has been initialized
    let videoHasPlayed = false; // Permanent flag to track if video has been played in this session
    
    // Audio/Music state
    let currentMusic = null;
    let musicVolume = 0.7;
    let musicEnabled = true;
    
    // Session tracking for heartbeat verification
    let currentSessionId = null;
    let heartbeatInterval = null;
    let heartbeatCount = 0;

    // Create colored fallback textures
    function createFallbackTexture(color) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, 64, 64);
      return new THREE.CanvasTexture(canvas);
    }

    // Game variables
    let playerVelocity = 0;
    const gravity = 0.7;
    const terminalVelocity = -18; // Maximum fall speed (prevents infinite acceleration)
    const desktopFlapStrength = 14;
    const mobileFlapStrength = 9; // Reduced flap strength for mobile devices
    let flapStrength = desktopFlapStrength; // Default to desktop value, will be updated based on device
    
    // Delta time for frame-rate independent physics
    let lastFrameTime = 0;
    const targetFPS = 60;
    const targetFrameTime = 1000 / targetFPS; // ~16.67ms per frame at 60fps
    let retryCount = 0; // Changed from pizzaCount to retryCount
    let laserCount = 0;
    let score = 0;
    let gameOver = false;
    let isRespawning = false;
    let laserBonusActive = false;
    let gameStartTime = 0;
    let backgroundSpeed = 2;
    let respawnCountdown = 0;

    // Full Power mode variables
    let fullPowerMode = false;
    let fullPowerTimer = 0;
    let fullPowerDuration = 3000; // 3 seconds in milliseconds
    let lastLaserFireTime = 0;
    let laserFireInterval = 200; // Fire lasers every 200ms during full power

    // Texture loader with fallback
    const textureLoader = new THREE.TextureLoader();
    function loadTextureWithFallback(path, fallbackColor, callback) {
      const fallback = createFallbackTexture(fallbackColor);
      textureLoader.load(
        path,
        texture => {
          // Fix aspect ratio issues by setting these properties
          texture.matrixAutoUpdate = true;
          callback(texture);
        },
        undefined,
        () => callback(fallback)
      );
      return fallback; // Return fallback immediately for initial use
    }

    // Player setup
    let playerTexture = createFallbackTexture('red');
    let playerTextureGlow1 = createFallbackTexture('red'); // Left eye glow
    let playerTextureGlow2 = createFallbackTexture('red'); // Left + middle eye glow
    let playerTextureGlow3 = createFallbackTexture('red'); // All eyes glowing
    let playerTextureBonusActive = null; // Will use glow3 if not loaded
    
    // Determine if we're on a mobile device with portrait orientation
    function isMobilePortrait() {
      return window.innerWidth < window.innerHeight && window.innerWidth < 768;
    }
    
    // Adjust player size and position based on device
    // Rocket Pizza image has ~4:3 aspect ratio (wider than tall)
    function getPlayerSize() {
      if (isMobilePortrait()) {
        // Mobile portrait: 30% smaller (70% of original size)
        return { width: 137, height: 105 }; // ~1.3:1 ratio, scaled down
      } else {
        // Desktop or landscape: original size
        return { width: 195, height: 150 }; // ~1.3:1 ratio to match actual image
      }
    }
    
    // Get horizontal position for player
    function getPlayerXPosition() {
      // Use the same left-side positioning for all devices
      return -80; // Consistent left positioning for all devices
    }
    
    // Load all player textures
    loadTextureWithFallback('Assets/Visual/Rocket Pizza.png', 'red', texture => {
      console.log("Base rocket texture loaded successfully");
      playerTexture = texture;
      if (!playerTextureLoaded) {
        player.material.map = texture;
        player.material.needsUpdate = true;
        playerTextureLoaded = true;
      }
    });
    
    loadTextureWithFallback('Assets/Visual/Rocket Pizza_eye glow 1.png', 'red', texture => {
      console.log("Rocket glow 1 texture loaded successfully");
      playerTextureGlow1 = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/Rocket Pizza_eye glow 2.png', 'red', texture => {
      console.log("Rocket glow 2 texture loaded successfully");
      playerTextureGlow2 = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/Rocket Pizza_eye glow 3.png', 'red', texture => {
      console.log("Rocket glow 3 texture loaded successfully");
      playerTextureGlow3 = texture;
      playerTextureBonusActive = texture; // Use glow3 for bonus mode if no specific bonus texture
    });
    
    // Flag to track if the default texture has been loaded and applied
    let playerTextureLoaded = false;
    
    // Create a container for the player so we can rotate it properly
    const playerContainer = new THREE.Object3D();
    const playerSizeObj = getPlayerSize();
    const playerXPosition = getPlayerXPosition();
    playerContainer.position.set(playerXPosition, 0, 0);
    scene.add(playerContainer);
    
    // Create the player sprite inside the container
    const playerMaterial = new THREE.SpriteMaterial({ 
      map: playerTexture,
      transparent: true
    });
    const player = new THREE.Sprite(playerMaterial);
    player.scale.set(playerSizeObj.width, playerSizeObj.height, 1);
    player.width = playerSizeObj.width;
    player.height = playerSizeObj.height;
    // Add sprite to container instead of directly to scene
    playerContainer.add(player);
    
    // Apply rotation to the container (5 degrees clockwise)
    playerContainer.rotation.z = -5 * (Math.PI / 180);
    
    // Create a pizza icon for retries
    function createPizzaIcon() {
      const icon = document.createElement('img');
      icon.src = 'Assets/Visual/pizza slice.png'; // Use the same pizza image
      icon.className = 'pizza-icon';
      return icon;
    }
    
    // Update the retry display with pizza icons
    function updateRetryDisplay() {
      const container = document.getElementById('retry-icons');
      // Clear existing icons
      container.innerHTML = '';
      
      // Add an icon for each retry
      for (let i = 0; i < retryCount; i++) {
        container.appendChild(createPizzaIcon());
      }
    }

    // Respawn the player after using a retry
    function respawnPlayer() {
      console.log("Respawning player, retries remaining:", retryCount - 1);
      isRespawning = true;
      retryCount--; // Use one retry
      updateRetryDisplay();
      
      // Stop animation frame during respawn to prevent further collisions
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Show respawn message
      const respawnMsg = document.getElementById('respawn-message');
      respawnMsg.style.display = 'block';
      
      // Reset player position and velocity
      const playerXPosition = getPlayerXPosition();
      playerContainer.position.set(playerXPosition, 0, 0); // Use responsive position
      playerVelocity = 0;
      
      // Clear any active enemies near the respawn point for safety
      const safeZone = 300; // Safe zone width
      for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].position.x < playerContainer.position.x + safeZone) {
          scene.remove(enemies[i]);
          enemies.splice(i, 1);
        }
      }
      
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].position.x < playerContainer.position.x + safeZone) {
          scene.remove(obstacles[i]);
          obstacles.splice(i, 1);
        }
      }
      
      // Start countdown
      respawnCountdown = 3;
      document.getElementById('respawn-countdown').textContent = respawnCountdown;
      
      // Start countdown timer
      const countdownInterval = setInterval(() => {
        respawnCountdown--;
        document.getElementById('respawn-countdown').textContent = respawnCountdown;
        
        if (respawnCountdown <= 0) {
          clearInterval(countdownInterval);
          // Hide respawn message
          respawnMsg.style.display = 'none';
          
          // Give player a grace period by resetting gameStartTime
          gameStartTime = 0;
          
          // Resume game
          isRespawning = false;
          
          // Give an initial boost to prevent immediate falling
          playerVelocity = flapStrength;
          
          // Make sure animation is running - this is crucial!
          if (!animationFrameId) {
            console.log("Restarting animation after respawn");
            animationFrameId = requestAnimationFrame(animate);
          }
        }
      }, 1000);
    }

    // Create snow effect for intro screen
    function createIntroSnow() {
      const container = document.getElementById('intro-snow-container');
      if (!container) return;
      
      // Clear any existing snowflakes
      container.innerHTML = '';
      
      // Create HEAVY snowfall (500 snowflakes)
      const numSnowflakes = 500;
      
      for (let i = 0; i < numSnowflakes; i++) {
        const snowflake = document.createElement('div');
        snowflake.className = 'intro-snowflake';
        
        // Random size (3-12px for more visible snow)
        const size = Math.random() * 9 + 3;
        snowflake.style.width = size + 'px';
        snowflake.style.height = size + 'px';
        
        // Random horizontal position
        snowflake.style.left = Math.random() * 100 + '%';
        
        // Random starting vertical position (spread across screen)
        snowflake.style.top = (Math.random() * 120 - 20) + '%';
        
        // Random animation duration (2-6 seconds for faster snow)
        const duration = Math.random() * 4 + 2;
        snowflake.style.animationDuration = duration + 's';
        
        // Random delay - start immediately for some, delayed for others
        snowflake.style.animationDelay = (Math.random() * 3) + 's';
        
        // Vary the horizontal drift (wind effect)
        const drift = (Math.random() - 0.3) * 150; // Bias toward right (wind)
        snowflake.style.setProperty('--drift', drift + 'px');
        
        // Vary opacity for depth effect
        snowflake.style.opacity = 0.5 + Math.random() * 0.5;
        
        container.appendChild(snowflake);
      }
      
      console.log("Created HEAVY intro snow effect with " + numSnowflakes + " snowflakes");
    }
    
    // Clear intro snow when transitioning to gameplay
    function clearIntroSnow() {
      const container = document.getElementById('intro-snow-container');
      if (container) {
        container.innerHTML = '';
      }
    }

    // Start Crypto Winter hidden level intro
    function startCryptoWinterIntro() {
      console.log("=== ENTERING CRYPTO WINTER HIDDEN LEVEL ===");
      cryptoWinterIntroPlaying = true;
      
      // Stop the game animation
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Stop current music
      stopBackgroundMusic();
      
      // Get overlay elements
      const introOverlay = document.getElementById('crypto-winter-intro');
      const video = document.getElementById('crypto-winter-video');
      const wordWelcome = document.getElementById('word-welcome');
      const wordTo = document.getElementById('word-to');
      const wordCrypto = document.getElementById('word-crypto');
      const wordWinter = document.getElementById('word-winter');
      
      // Reset word visibility
      wordWelcome.classList.remove('visible');
      wordTo.classList.remove('visible');
      wordCrypto.classList.remove('visible');
      wordWinter.classList.remove('visible');
      
      // Show overlay
      introOverlay.style.display = 'flex';
      
      // Create intro snow effect
      createIntroSnow();
      
      // Load and play audio (only if music is enabled)
      cryptoWinterAudio = new Audio('Assets/Audio/welcome_to_crypto_winter.mp3');
      cryptoWinterAudio.volume = 1.0;
      
      // When welcome audio ends, play the howling wind audio on loop
      cryptoWinterAudio.onended = () => {
        if (!musicEnabled) return; // Don't play if muted
        console.log("Welcome audio ended, playing wind audio on loop...");
        cryptoWinterWindAudio = new Audio('Assets/Audio/howling_winter_wind__%231.mp3');
        cryptoWinterWindAudio.volume = 1.0;
        cryptoWinterWindAudio.loop = true; // Loop the wind audio
        cryptoWinterWindAudio.play().then(() => {
          console.log("Wind audio playing successfully (looping)");
        }).catch(e => console.log("Wind audio play error:", e));
      };
      
      // Check if on mobile device
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
      
      // Play video
      video.currentTime = 0;
      
      video.play().catch(e => {
        console.log("Video play error (likely mobile autoplay blocked):", e);
        // Video failed but intro will auto-end via timeout
      });
      
      // Play audio (only if music is enabled)
      if (musicEnabled) {
        cryptoWinterAudio.play().catch(e => {
          console.log("Audio play error (likely mobile autoplay blocked):", e);
        });
      }
      
      // Mobile auto-continues after a short delay (no tap needed)
      
      // Time the word appearances to sync with audio "Welcome to Crypto Winter"
      // Timings matched to spoken words in audio file
      setTimeout(() => {
        wordWelcome.classList.add('visible');
        console.log("Word: WELCOME");
      }, 100); // "Welcome" appears at 0.1s
      
      setTimeout(() => {
        wordTo.classList.add('visible');
        console.log("Word: TO");
      }, 700); // "to" appears at 0.7s
      
      setTimeout(() => {
        wordCrypto.classList.add('visible');
        console.log("Word: CRYPTO");
      }, 1000); // "Crypto" appears at 1.0s
      
      setTimeout(() => {
        wordWinter.classList.add('visible');
        console.log("Word: WINTER");
      }, 1600); // "Winter" appears at 1.6s
      
      // End intro when VIDEO finishes (let the full video play)
      video.onended = () => {
        endCryptoWinterIntro();
      };
      
      // Fallback timeout - shorter for mobile (6 seconds), longer for desktop (30 seconds)
      const fallbackTimeout = isMobileDevice ? 6000 : 30000;
      setTimeout(() => {
        if (cryptoWinterIntroPlaying) {
          console.log("Fallback timeout triggered - ending intro");
          endCryptoWinterIntro();
        }
      }, fallbackTimeout);
    }
    
    // End Crypto Winter intro and continue to the level
    function endCryptoWinterIntro() {
      if (!cryptoWinterIntroPlaying) return;
      
      console.log("=== CRYPTO WINTER INTRO COMPLETE ===");
      cryptoWinterIntroPlaying = false;
      
      // Clear intro snow
      clearIntroSnow();
      inCryptoWinter = true;
      cryptoWinterFirstTap = false; // Reset first tap tracking for slow-fall grace period
      cryptoWinterStartTime = Date.now(); // Start timer for progressive snow
      currentSnowIntensity = 0; // Reset snow intensity
      windStrength = 0.05; // Start with light wind
      
      // Remove foreground elements from main game (don't carry into Crypto Winter)
      if (foregroundSnowpile) {
        foregroundSnowpile.visible = false;
        scene.remove(foregroundSnowpile);
        foregroundSnowpile = null;
      }
      if (foregroundSnowpileRight) {
        foregroundSnowpileRight.visible = false;
        scene.remove(foregroundSnowpileRight);
        foregroundSnowpileRight = null;
      }
      if (foregroundBush) {
        foregroundBush.visible = false;
        scene.remove(foregroundBush);
        foregroundBush = null;
      }
      
      // Reset laser eyes - they don't carry over to Crypto Winter
      laserCount = 0;
      
      // Switch to snow version of player character (25% larger)
      if (textureCache.playerSnow) {
        player.material.map = textureCache.playerSnow;
        player.material.needsUpdate = true;
        // Make snow character 25% larger
        const playerSizeObj = getPlayerSize();
        player.scale.set(playerSizeObj.width * 1.25, playerSizeObj.height * 1.25, 1);
        player.width = playerSizeObj.width * 1.25;
        player.height = playerSizeObj.height * 1.25;
        console.log("Switched to snow player texture (25% larger)");
      }
      
      // Hide overlay
      const introOverlay = document.getElementById('crypto-winter-intro');
      const video = document.getElementById('crypto-winter-video');
      
      // Stop video and audio
      video.pause();
      if (cryptoWinterAudio) {
        cryptoWinterAudio.pause();
        cryptoWinterAudio = null;
      }
      
      introOverlay.style.display = 'none';
      
      // Reset player position - start near top so player gently falls during grace period
      const playerXPosition = getPlayerXPosition();
      playerContainer.position.set(playerXPosition, window.innerHeight * 0.15, 0);
      playerVelocity = 0; // No initial boost - let player gently fall with reduced gravity
      
      // Clear ALL enemies, obstacles, and collectibles
      for (let i = enemies.length - 1; i >= 0; i--) {
        scene.remove(enemies[i]);
      }
      enemies.length = 0;
      
      for (let i = obstacles.length - 1; i >= 0; i--) {
        scene.remove(obstacles[i]);
      }
      obstacles.length = 0;
      
      // Clear collectibles (pizzas and bitcoins) - they shouldn't appear in Crypto Winter
      for (let i = collectibles.length - 1; i >= 0; i--) {
        scene.remove(collectibles[i]);
      }
      collectibles.length = 0;
      
      // Set up Crypto Winter snow backgrounds
      setupCryptoWinterBackgrounds();
      currentBackgroundIndex = 0; // Reset to first Crypto Winter background
      
      // Create foreground tree for parallax effect
      createForegroundTree();
      
      // Don't start gameplay music - the howling wind audio continues from intro
      
      // Resume game
      gameStartTime = performance.now(); // Reset start time for grace period
      lastFrameTime = performance.now(); // Reset delta time to prevent huge first-frame jump
      if (!animationFrameId) {
        animationFrameId = requestAnimationFrame(animate);
      }
      
      console.log("Crypto Winter level started!");
    }

    // Update UI elements
    function updateUI() {
      document.getElementById('score').textContent = `Score: ${Math.floor(score)}`;
      document.getElementById('laser-count').textContent = `Laser Eyes: ${laserCount}/3`;
      // Retry display is updated separately in updateRetryDisplay()
    }

    // Function to update the player texture based on laser count and bonus mode
    function updatePlayerTexture() {
      console.log("Updating player texture based on laserCount:", laserCount, "bonusActive:", laserBonusActive, "fullPower:", fullPowerMode, "inCryptoWinter:", inCryptoWinter);
      
      // In Crypto Winter, use the snow player texture (no laser eyes in Crypto Winter)
      if (inCryptoWinter && textureCache.playerSnow) {
        player.material.map = textureCache.playerSnow;
        player.material.needsUpdate = true;
        console.log("Using snow player texture for Crypto Winter");
        return;
      }
      
      // Make sure we have a valid texture before updating
      let textureToUse;
      
      if (fullPowerMode && playerTextureGlow3) {
        // Always use all eyes glowing during full power mode
        textureToUse = playerTextureGlow3;
        console.log("Using full power texture (ALL eyes)");
      } else if (laserBonusActive && playerTextureGlow3) {
        // Use the bonus/all-eyes texture when in bonus mode
        textureToUse = playerTextureGlow3;
        console.log("Using bonus/all eyes texture");
      } else {
        // Choose texture based on laser count
        if (laserCount === 0 && playerTexture) {
          textureToUse = playerTexture; // No glow
          console.log("Using base texture (no glow)");
        } else if (laserCount === 1 && playerTextureGlow1) {
          textureToUse = playerTextureGlow1; // Left eye only
          console.log("Using glow 1 texture (LEFT eye)");
        } else if (laserCount === 2 && playerTextureGlow2) {
          textureToUse = playerTextureGlow2; // Left + middle eyes
          console.log("Using glow 2 texture (LEFT+MIDDLE eyes)");
        } else if (laserCount >= 3 && playerTextureGlow3) {
          textureToUse = playerTextureGlow3; // All eyes
          console.log("Using glow 3 texture (ALL eyes)");
        } else {
          console.log("No valid texture found for current state, keeping current texture");
          return; // Don't update if we don't have a valid texture
        }
      }
      
      // Only update if we have a valid texture
      if (textureToUse) {
        player.material.map = textureToUse;
        player.material.needsUpdate = true;
      }
    }
    
    // LASER BEAM SYSTEM
    const laserBeams = [];
    const maxLaserBeams = 10;
    
    // Explosion system variables - moved to the top
    const explosionPool = [];
    const maxExplosions = 10;
    
    // Create a more visible laser beam
    function createThickLaserBeam() {
      // Create a simpler, but highly visible laser beam
      const laserWidth = 6; // Reduced from 10 to 6 for a thinner beam
      const laserGeometry = new THREE.PlaneGeometry(1, laserWidth);
      
      // Simpler material without texture to ensure it works
      const laserMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000, // Bright red
        transparent: true,
        opacity: 1.0, // Already at maximum opacity
        side: THREE.DoubleSide,
        depthTest: false,
        blending: THREE.AdditiveBlending
      });
      
      const beam = new THREE.Mesh(laserGeometry, laserMaterial);
      
      // Add simple glow
      const glowGeometry = new THREE.PlaneGeometry(1, laserWidth * 1.5); // Reduced from 2x to 1.5x for a thinner glow
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.7, // Increased from 0.4 to 0.7 for more visibility
        side: THREE.DoubleSide,
        depthTest: false,
        blending: THREE.AdditiveBlending
      });
      
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      beam.add(glow);
      
      beam.visible = false;
      beam.userData = { 
        active: false,
        progress: 0,
        fixationTime: 0,
        fixationPhase: false,
        startPos: new THREE.Vector3(),
        endPos: new THREE.Vector3(),
        eyeIndex: 0
      };
      
      beam.renderOrder = 100;
      scene.add(beam);
      return beam;
    }
    
    // Initialize the laser beam pool and explosion system
    function initLaserBeams() {
      // Create several laser beam objects that we can reuse
      for (let i = 0; i < maxLaserBeams; i++) {
        // Create thicker beam using plane geometry
        const beam = createThickLaserBeam();
        laserBeams.push(beam);
      }
      console.log("Initialized", maxLaserBeams, "laser beams");
      
      // Initialize the explosion particles
      initExplosions();
      console.log("Initialized explosion system");
    }
    
    // Function to get eye position based on current laser count
    function getEyePosition(eyeIndex) {
      // Define positions of the three eyes relative to player center
      // These values are based on the Rocket Pizza sprite design
      const eyePositions = [
        new THREE.Vector3(-35, 25, 1),  // Left eye (adjusted x from -40 to -35)
        new THREE.Vector3(0, 40, 1),    // Middle (top) eye
        new THREE.Vector3(35, 25, 1)    // Right eye (adjusted x from 40 to 35)
      ];
      
      // Get the specified eye position, clamped to valid indices
      const index = Math.max(0, Math.min(eyeIndex, 2));
      
      // Add safety check
      if (index < 0 || index >= eyePositions.length) {
        console.error("Invalid eye index:", eyeIndex);
        return new THREE.Vector3(0, 0, 1).add(playerContainer.position); // Default position
      }
      
      const position = eyePositions[index].clone();
      console.log(`Getting eye position for index ${index}: (${position.x}, ${position.y})`);
      
      // Apply rotation matrix to account for player rotation
      position.applyAxisAngle(new THREE.Vector3(0, 0, 1), playerContainer.rotation.z);
      
      // Convert to world position by adding player container position
      position.x += playerContainer.position.x;
      position.y += playerContainer.position.y;
      
      return position;
    }
    
    // Function to shoot a laser from one of the player's eyes
    function shootLaserAt(target, specificEyeIndex) {
      // Debug info
      console.log("------------------------------");
      console.log("SHOOTING LASER:");
      console.log("Target position:", target.position.x, target.position.y);
      console.log("Current laser count:", laserCount);
      
      // Use the provided eye index or determine which eye to fire from
      let eyeIndex = specificEyeIndex;
      
      if (eyeIndex === undefined) {
        if (laserBonusActive) {
          // During laser bonus, randomly choose which eye to fire from
          eyeIndex = Math.floor(Math.random() * 3);
        } else {
          // Use the eye that corresponds to the current laser count
          eyeIndex = Math.min(laserCount - 1, 2); // Cap at 2 (third eye)
        }
      }
      
      // Ensure eye index is valid (0-2)
      eyeIndex = Math.max(0, Math.min(2, eyeIndex));
      console.log("Using eye index:", eyeIndex);
      
      // Play the appropriate zap sound based on which eye is firing
      let zapSound;
      
      if (eyeIndex === 0) {
        zapSound = 'zap1';
      } else if (eyeIndex === 1) {
        zapSound = 'zap2';
      } else if (eyeIndex === 2) {
        zapSound = 'zap3';
      }
      
      // Play the specific zap sound based on the eye
      if (zapSound) {
        playDirectSound(zapSound);
        logAudio(`Triggered zap sound: ${zapSound} for eye ${eyeIndex}`);
      }
      
      // Get the starting position for the laser beam
      const startPos = getEyePosition(eyeIndex);
      console.log("Starting position:", startPos.x, startPos.y);
      
      // Get first inactive laser beam from the pool
      const beam = laserBeams.find(b => !b.userData.active);
      if (!beam) {
        console.log("No available beams!");
        return; // No available beams
      }
      
      // Get position of target
      const endPos = new THREE.Vector3(target.position.x, target.position.y, 2);
      console.log("Target position:", endPos.x, endPos.y);
      
      // Move the beam to the start position
      beam.position.copy(startPos);
      beam.position.z = 2;
      
      // Store data for animation
      beam.userData.startPos = startPos.clone();
      beam.userData.endPos = endPos.clone();
      beam.userData.active = true;
      beam.userData.progress = 0;
      beam.userData.fixationPhase = false;
      beam.userData.fixationTime = 30;
      beam.userData.eyeIndex = eyeIndex;
      beam.userData.targetObj = target; // Store reference to the target
      
      // Make it visible
      beam.visible = true;
      console.log("Beam activated:", beam.visible, "eyeIndex:", beam.userData.eyeIndex);
      console.log("------------------------------");
    }
    
    // Function to position and scale a beam between two points
    function positionBeam(beam, start, end) {
      // Calculate the center position between start and end
      const center = new THREE.Vector3()
        .addVectors(start, end)
        .multiplyScalar(0.5);
      
      // Set the beam at this center
      beam.position.copy(center);
      beam.position.z = 2; // Ensure it's in front
      
      // Calculate direction and distance
      const direction = new THREE.Vector3().subVectors(end, start);
      const length = direction.length();
      
      // For advanced beams, only scale core and glows
      if (beam.userData.beam) {
        beam.userData.beam.scale.set(length, beam.userData.beam.scale.y, 1);
        beam.userData.innerGlow.scale.set(length, beam.userData.innerGlow.scale.y, 1);
        beam.userData.outerGlow.scale.set(length, beam.userData.outerGlow.scale.y, 1);
      } else {
        // Legacy scaling for simple beams
        beam.scale.set(length, beam.scale.y, 1);
      }
      
      // Calculate angle to rotate the beam
      const angle = Math.atan2(direction.y, direction.x);
      beam.rotation.z = angle;
    }
    
    // Function to update active laser beams
    function updateLaserBeams() {
      for (let i = 0; i < laserBeams.length; i++) {
        const beam = laserBeams[i];
        
        if (beam.userData.active) {
          // Update animation phases
          beam.userData.pulsePhase = (beam.userData.pulsePhase || 0) + 0.1;
          const pulseVal = Math.sin(beam.userData.pulsePhase) * 0.5 + 0.5; // 0 to 1 pulse
          
          // Always update the starting position to follow the eye as the player moves
          const currentEyePos = getEyePosition(beam.userData.eyeIndex);
          beam.userData.startPos.copy(currentEyePos);
          
          const startPos = beam.userData.startPos;
          const endPos = beam.userData.endPos;
          
          if (!beam.userData.fixationPhase) {
            // Extension phase - beam is traveling toward target
            beam.userData.progress += 0.2; // Faster beam movement
            
            if (beam.userData.progress >= 1) {
              // Beam has reached the target, start fixation phase
              beam.userData.fixationPhase = true;
              
              // Create an explosion at the target position
              createExplosion(endPos, 0x00ffff); // Cyan/blue explosion
            }
            
            // Calculate current endpoint based on progress
            const currentEnd = new THREE.Vector3().lerpVectors(
              startPos,
              endPos,
              beam.userData.progress
            );
            
            // Position the main beam container
            positionBeam(beam, startPos, currentEnd);
            
            // Position rings along beam length
            if (beam.userData.rings) {
              const beamDirection = new THREE.Vector3().subVectors(currentEnd, startPos).normalize();
              const beamLength = startPos.distanceTo(currentEnd);
              
              beam.userData.rings.forEach((ring, index) => {
                // Space rings evenly along beam
                const t = (index / (beam.userData.rings.length - 1)) * 0.8 + 0.1;
                const ringPos = new THREE.Vector3().lerpVectors(startPos, currentEnd, t);
                
                // Add small fluctuation
                const offset = Math.sin(beam.userData.pulsePhase + index) * 5;
                ringPos.add(beamDirection.clone().multiplyScalar(offset));
                
                ring.position.copy(ringPos);
                
                // Scale and opacity animation
                const scale = 0.5 + 0.5 * Math.sin(beam.userData.pulsePhase * 2 + index);
                ring.scale.set(scale, scale, scale);
                ring.material.opacity = 0.4 + 0.3 * pulseVal;
              });
            }
            
            // Update particles
            if (beam.userData.particles) {
              const beamDirection = new THREE.Vector3().subVectors(currentEnd, startPos).normalize();
              const beamLength = startPos.distanceTo(currentEnd);
              
              beam.userData.particles.forEach((particle, index) => {
                // Random position along beam
                const t = Math.sin(beam.userData.pulsePhase + index * 0.1) * 0.5 + 0.5;
                const particlePos = new THREE.Vector3().lerpVectors(startPos, currentEnd, t);
                
                // Add random offset perpendicular to beam
                const perpOffset = new THREE.Vector3(
                  Math.sin(beam.userData.pulsePhase * 2 + index),
                  Math.cos(beam.userData.pulsePhase * 3 + index),
                  0
                );
                perpOffset.multiplyScalar(3 + Math.sin(beam.userData.pulsePhase + index * 0.5) * 2);
                
                particlePos.add(perpOffset);
                particle.position.copy(particlePos);
                
                // Size pulse and flicker
                const particleScale = 0.5 + Math.random() * 1.5;
                particle.scale.set(particleScale, particleScale, 1);
                
                // Opacity flicker
                particle.material.opacity = Math.random() * 0.5 + 0.2;
                
                // Color variation
                const hue = (beam.userData.pulsePhase * 0.05 + index * 0.1) % 1;
                particle.material.color.setHSL(0.5, 0.8, 0.7 + 0.3 * Math.random()); // Blue-cyan range
              });
            }
            
            // Pulse beam core and glows
            if (beam.userData.beam) {
              // Core beam intensity pulses
              beam.userData.beam.material.opacity = 0.7 + 0.3 * pulseVal;
              // Glow effects pulse in opposite phase
              beam.userData.innerGlow.material.opacity = 0.6 + 0.4 * (1 - pulseVal);
              beam.userData.outerGlow.material.opacity = 0.3 + 0.2 * pulseVal;
            }
          } else {
            // Fixation phase - beam is fixed on target
            beam.userData.fixationTime--;
            
            // Keep beam positioned at full extension
            positionBeam(beam, startPos, endPos);
            
            // Continued animation of rings and particles during fixation
            if (beam.userData.rings) {
              const beamDirection = new THREE.Vector3().subVectors(endPos, startPos).normalize();
              const beamLength = startPos.distanceTo(endPos);
              
              beam.userData.rings.forEach((ring, index) => {
                // Space rings evenly along beam
                const t = (index / (beam.userData.rings.length - 1)) * 0.8 + 0.1;
                const ringPos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
                
                // Add small fluctuation
                const offset = Math.sin(beam.userData.pulsePhase + index) * 5;
                ringPos.add(beamDirection.clone().multiplyScalar(offset));
                
                ring.position.copy(ringPos);
                
                // Scale and opacity animation
                const scale = 0.5 + 0.5 * Math.sin(beam.userData.pulsePhase * 2 + index);
                ring.scale.set(scale, scale, scale);
                
                // Fade out rings as fixation ends
                if (beam.userData.fixationTime < 10) {
                  ring.material.opacity = (beam.userData.fixationTime / 10) * (0.4 + 0.3 * pulseVal);
                }
              });
            }
            
            // Update particles during fixation
            if (beam.userData.particles) {
              // Similar animation as extension phase but fade out at end
              beam.userData.particles.forEach((particle, index) => {
                // Fade out particles as fixation ends
                if (beam.userData.fixationTime < 10) {
                  particle.material.opacity = (beam.userData.fixationTime / 10) * (Math.random() * 0.5 + 0.2);
                }
              });
            }
            
            // Fade out beam core and glows as fixation ends
            if (beam.userData.beam && beam.userData.fixationTime < 10) {
              const fadeRatio = beam.userData.fixationTime / 10;
              beam.userData.beam.material.opacity = fadeRatio * (0.7 + 0.3 * pulseVal);
              beam.userData.innerGlow.material.opacity = fadeRatio * (0.6 + 0.4 * (1 - pulseVal));
              beam.userData.outerGlow.material.opacity = fadeRatio * (0.3 + 0.2 * pulseVal);
            }
            
            // If fixation time is over, deactivate the beam
            if (beam.userData.fixationTime <= 0) {
              beam.visible = false;
              beam.userData.active = false;
            }
          }
        }
      }
      
      // Update explosion particles
      updateExplosions();
    }

    // Background setup
    const backgroundFiles = [
      'Assets/Visual/background.png',              // Index 0
      'Assets/Visual/background2.png',             // Index 1
      'Assets/Visual/background3.png',             // Index 2
      'Assets/Visual/background_Jaipur_Vishnu.jpg', // Index 3 - Jaipur
      'Assets/Visual/background_praha.png',        // Index 4 - Prague
      'Assets/Visual/background_Vienna.jpg',       // Index 5 - Vienna
      'Assets/Visual/background7_barcelona.jpg',   // Index 6 - City background - Barcelona
      'Assets/Visual/background8_new york.jpg',    // Index 7 - City background - New York
      'Assets/Visual/oslo.png',                    // Index 8 - City background - Oslo (Crypto Winter entry)
      'Assets/Visual/background9_rio.jpg',         // Index 9 - City background - Rio
      'Assets/Visual/background10_tokyo.png',      // Index 10 - City background - Tokyo
      'Assets/Visual/background11_cemetery entrance.png', // Index 11 - Cemetery entrance background
      'Assets/Visual/background12_cemetery.png',   // Index 12 - Cemetery background
      'Assets/Visual/background13_moon.png'        // Index 13 - Moon background (final)
    ];
    
    const backgrounds = [];
    let backgroundWidth = window.innerWidth;
    let backgroundHeight = window.innerHeight;
    
    // Function to calculate background dimensions with proper aspect ratio
    function calculateBackgroundDimensions() {
      // For vertical mobile screens, maintain a minimum width to avoid compression
      if (isMobilePortrait()) {
        // Use a fixed aspect ratio for backgrounds (16:9 or 4:3 are common)
        const minWidth = window.innerHeight * 1.77; // 16:9 aspect ratio
        backgroundWidth = Math.max(window.innerWidth, minWidth);
      } else {
        backgroundWidth = window.innerWidth;
      }
      backgroundHeight = window.innerHeight;
    }
    
    // Calculate initial dimensions
    calculateBackgroundDimensions();
    
    // Track which background is currently visible in center screen
    let currentBackgroundIndex = 0; 
    let isCityBackground = false;
    let isMoonBackground = false;
    let fadeInProgress = false;
    
    // Crypto Winter hidden level
    let inCryptoWinter = false;
    let cryptoWinterIntroPlaying = false;
    let cryptoWinterAudio = null;
    let cryptoWinterWindAudio = null;
    let cryptoWinterFirstTap = false; // Track if player has done first tap in ice level (for slow-fall grace period)
    
    // Snow particle system for Crypto Winter
    const snowParticles = [];
    let currentSnowIntensity = 0; // 0-4 based on time progression
    let windStrength = 0; // Wind effect strength
    const maxSnowParticles = 800; // Maximum snow particles on screen for whiteout
    let cryptoWinterStartTime = 0; // When Crypto Winter level started
    const snowIntensityInterval = 8000; // 8 seconds per intensity level (faster progression)
    
    // Crypto Winter background files
    const cryptoWinterBackgroundFiles = [
      'Assets/Visual/snow_background_1.png',
      'Assets/Visual/snow_background_2.png',
      'Assets/Visual/snow_background_3.png',
      'Assets/Visual/snow_background_4.png',
      'Assets/Visual/snow_background_5.png',
      'Assets/Visual/snow_background_6.png'
    ];
    const cryptoWinterBackgrounds = [];
    
    // Crypto Winter ending sequence variables
    let cryptoWinterEnding = false;
    let greenCandleAudio = null;
    let greenCandleSprite = null;
    let sunlightOverlay = null;
    let cryptoWinterCurrentBgIndex = 0;
    let exitingCryptoWinter = false; // Prevent multiple exit triggers
    let greenCandleReachedSunlight = false; // Track if candle has reached the sunlight
    
    // Foreground trees for Crypto Winter (appears in front of player on background 3)
    let foregroundTree = null;
    let foregroundTree2 = null;
    let foregroundTreeVisible = false;
    
    // Foreground bush for main game (hides seam between background3 and Jaipur)
    let foregroundBush = null;
    let foregroundBushTriggered = false;
    
    // Foreground snowpile for main game (hides seam at Oslo level)
    let foregroundSnowpile = null;
    let foregroundSnowpileRight = null; // For the right seam of Oslo (Oslo to Rio)
    
    // Create fade overlay for transitions
    const fadeOverlay = document.createElement('div');
    fadeOverlay.id = 'fade-overlay';
    fadeOverlay.style.position = 'absolute';
    fadeOverlay.style.top = '0';
    fadeOverlay.style.left = '0';
    fadeOverlay.style.width = '100%';
    fadeOverlay.style.height = '100%';
    fadeOverlay.style.backgroundColor = 'black';
    fadeOverlay.style.opacity = '0';
    fadeOverlay.style.zIndex = '250'; // Below the video but above everything else
    fadeOverlay.style.pointerEvents = 'none'; // Don't intercept clicks
    fadeOverlay.style.transition = 'opacity 2s ease-in-out';
    document.body.appendChild(fadeOverlay);
    
    // Function to check if a background is in the center view with enough visibility to count as active
    function checkBackgroundVisibility() {
      // Reset flags before checking
      isCityBackground = false;
      isMoonBackground = false;
      
      // Determine which background is in the center view
      let centerBackground = null;
      let centerVisibility = 0;
      
      // Check all backgrounds to find which one is most visible in center
      for (let i = 0; i < backgrounds.length; i++) {
        const bg = backgrounds[i];
        
        // Calculate how much of this background is in the center of screen
        const centerX = 0; // Center of screen
        const bgLeft = bg.position.x - backgroundWidth/2;
        const bgRight = bg.position.x + backgroundWidth/2;
        
        // Only consider backgrounds that overlap the center
        if (bgLeft <= centerX && bgRight >= centerX) {
          // Calculate how much of the center is covered by this background
          const leftSide = Math.max(bgLeft, -backgroundWidth/2);
          const rightSide = Math.min(bgRight, backgroundWidth/2);
          const visibleWidth = rightSide - leftSide;
          
          // If this background has more center coverage, make it the current one
          if (visibleWidth > centerVisibility) {
            centerVisibility = visibleWidth;
            centerBackground = bg;
          }
        }
      }
      
      // Now that we have the most center-visible background, check if it's a city
      // Or if it's the moon background
      if (centerBackground && centerBackground.userData && centerBackground.userData.fileIndex !== undefined) {
        currentBackgroundIndex = centerBackground.userData.fileIndex;
        
        // Check if it's a city background (Barcelona, New York, Oslo, Rio, or Tokyo) AND covers enough center
        if ((currentBackgroundIndex >= 6 && currentBackgroundIndex <= 10) && 
            (centerVisibility >= backgroundWidth * 0.5)) {
          isCityBackground = true;
          console.log("City background detected:", 
                    currentBackgroundIndex === 6 ? "Barcelona" : 
                    currentBackgroundIndex === 7 ? "New York" : 
                    currentBackgroundIndex === 8 ? "Oslo" :
                    currentBackgroundIndex === 9 ? "Rio" : "Tokyo", 
                    "Visibility:", Math.round(centerVisibility/backgroundWidth*100) + "%");
        } 
        // Check if it's the moon background (final) AND covers enough center
        else if (currentBackgroundIndex === backgroundFiles.length - 1 && 
                 centerVisibility >= backgroundWidth * 0.7) {
          isMoonBackground = true;
          console.log("🌙 Moon background detected!", 
                    "Visibility:", Math.round(centerVisibility/backgroundWidth*100) + "%");
          
          // If not already fading, moon is very visible, and video hasn't played yet, start fade transition
          if (!fadeInProgress && centerVisibility >= backgroundWidth * 0.9 && !videoHasPlayed && !gameOver) {
            fadeInProgress = true;
            startFadeToVideo();
          }
        }
        else {
          console.log("Regular background detected, index:", currentBackgroundIndex, 
                    "Visibility:", Math.round(centerVisibility/backgroundWidth*100) + "%");
        }
      }
      
      return isCityBackground;
    }

    // Function to update background positions for continuous scrolling
    function updateBackgrounds(speed) {
      // Skip if no backgrounds are loaded yet
      if (backgrounds.length === 0) return;
      
      for (let i = 0; i < backgrounds.length; i++) {
        // Move each background to the left
        backgrounds[i].position.x -= speed;
        
        // If a background goes completely off-screen to the left
        if (backgrounds[i].position.x < -backgroundWidth) {
          // Find the rightmost background
          let rightmostX = -Infinity;
          let rightmostIndex = 0;
          
          for (let j = 0; j < backgrounds.length; j++) {
            if (backgrounds[j].position.x > rightmostX) {
              rightmostX = backgrounds[j].position.x;
              rightmostIndex = j;
            }
          }
          
          // Place the off-screen background to the right of the rightmost one
          backgrounds[i].position.x = backgrounds[rightmostIndex].position.x + backgroundWidth;
        }
      }
      
      // Update which background is currently visible
      checkBackgroundVisibility();
    }
    
    // Function to ensure there's always a background visible on screen
    function ensureBackgroundsVisible() {
      // Find if there's a background visible in the center area
      let centerVisible = false;
      for (let i = 0; i < backgrounds.length; i++) {
        const bgLeft = backgrounds[i].position.x - backgroundWidth/2;
        const bgRight = backgrounds[i].position.x + backgroundWidth/2;
        
        // Check if this background covers center screen
        if (bgLeft <= 0 && bgRight >= 0) {
          centerVisible = true;
          break;
        }
      }
      
      // If no background is covering center screen, reposition one
      if (!centerVisible && backgrounds.length > 0) {
        // Find the background closest to center
        let closestBg = 0;
        let closestDist = Infinity;
        
        for (let i = 0; i < backgrounds.length; i++) {
          const dist = Math.abs(backgrounds[i].position.x);
          if (dist < closestDist) {
            closestDist = dist;
            closestBg = i;
          }
        }
        
        // Reposition it to cover center screen
        backgrounds[closestBg].position.x = 0;
      }
    }
    
    // Initialize backgrounds
    setupBackgrounds();

    // Initialize the laser beam system
    initLaserBeams();

    // Ground setup
    const groundGeometry = new THREE.PlaneGeometry(window.innerWidth * 10, 20);
    const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x3d3d3d }); // Dark gray ground
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.set(0, -window.innerHeight / 2 + 10, 0);
    scene.add(ground);

    // Game objects
    const enemies = [];
    const obstacles = [];
    const collectibles = [];
    const triggerX = 300; // Increased from 250 to 300 to account for wider sprites

    // Texture cache with fallbacks
    const textureCache = {
      'pizza': createFallbackTexture('yellow'),
      'bitcoin': createFallbackTexture('gold'),
      'enemy': createFallbackTexture('blue'),
      'building': createFallbackTexture('gray'),
      'candle': createFallbackTexture('red'),
      'candleLong': createFallbackTexture('darkred') // Add new red candle long texture cache entry
    };

    // Load textures
    loadTextureWithFallback('Assets/Visual/pizza slice.png', 'yellow', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.pizza = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/bitcoin.png', 'gold', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.bitcoin = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/blue mutant splattered.png', 'blue', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.enemy = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/bank building.png', 'gray', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.building = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/red candle.png', 'red', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.candle = texture;
    });
    
    // Load new red candle long texture
    loadTextureWithFallback('Assets/Visual/red candle long.png', 'darkred', texture => {
      texture.premultiplyAlpha = false; // Preserve transparency
      textureCache.candleLong = texture;
    });
    
    // Load Crypto Winter snow enemy textures
    loadTextureWithFallback('Assets/Visual/mutant_snow.png', 'lightblue', texture => {
      texture.premultiplyAlpha = false;
      textureCache.snowEnemy = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/candlesnow2.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.snowCandle = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/short_red_candle_snow.png', 'red', texture => {
      texture.premultiplyAlpha = false;
      textureCache.snowCandleShort = texture;
    });
    
    // Load bear enemy textures for Crypto Winter
    loadTextureWithFallback('Assets/Visual/bear_one_arm.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.bearIdle = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/bearstand.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.bearAggro = texture;
    });
    
    // Load foreground tree for Crypto Winter
    loadTextureWithFallback('Assets/Visual/snow_tree_4.png', 'darkgreen', texture => {
      texture.premultiplyAlpha = false;
      textureCache.snowTreeForeground = texture;
    });
    
    // Load snow version of player character for Crypto Winter
    loadTextureWithFallback('Assets/Visual/Rocket Pizza_snow.png', 'red', texture => {
      texture.premultiplyAlpha = false;
      textureCache.playerSnow = texture;
    });
    
    // Load second bear type textures for Crypto Winter
    loadTextureWithFallback('Assets/Visual/bear.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.bear2Idle = texture;
    });
    
    loadTextureWithFallback('Assets/Visual/bearmid.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.bear2Aggro = texture;
    });
    
    // Load bush texture for hiding background seams
    loadTextureWithFallback('Assets/Visual/bush.png', 'green', texture => {
      texture.premultiplyAlpha = false;
      textureCache.bush = texture;
    });
    
    // Load snowpile texture for hiding Oslo level seam
    loadTextureWithFallback('Assets/Visual/snowpile.png', 'white', texture => {
      texture.premultiplyAlpha = false;
      textureCache.snowpile = texture;
    });
    
    // Load green candle texture for Crypto Winter ending
    loadTextureWithFallback('Assets/Visual/green_candle.png', 'green', texture => {
      texture.premultiplyAlpha = false;
      textureCache.greenCandle = texture;
    });

    // Very simple direct audio system
    const gameAudio = document.getElementById('gameAudio');
    const audioTestBtn = document.getElementById('audio-test');
    const audioIndicator = document.getElementById('audio-indicator');
    let audioEnabled = false;
    
    // Sound file mappings - using only Audio folder
    const soundFiles = {
      'moltoBene': 'Assets/Audio/molto bene.mp3',
      'collectBitcoin': 'Assets/Audio/collect bitcoin.mp3',
      'zap1': 'Assets/Audio/zap 1.mp3',  // Specific zap sounds only
      'zap2': 'Assets/Audio/zap 2.mp3',
      'zap3': 'Assets/Audio/zap 3.mp3',
      'bearRoar1': 'Assets/Audio/polar_bear_roar_1.mp3',  // Bear #1 roar
      'bearRoar2': 'Assets/Audio/polar_bear_roar_2.mp3',  // Bear #2 roar
      'greenCandle': 'Assets/Audio/green_candle.mp3',    // Crypto Winter ending
      // Background music files with correct filenames
      'menuMusic': 'Assets/Audio/background_music_main_menu_pizza_shortie.mp3',
      'gameMusic1': 'Assets/Audio/background music_gameplay 1_Damn I Eat Pizza Like A Gangster.mp3',
      'gameMusic2': 'Assets/Audio/background music_gameplay 2_Pizza Mind.mp3',
      'gameMusic3': 'Assets/Audio/background music_gameplay 3_Pizza Avenue.mp3',
      'gameMusic4': 'Assets/Audio/background music_gameplay 4_Don\'t Worry Eat Pizza.mp3',
      'gameMusic5': 'Assets/Audio/background music_gameplay 5_Working For The Pizza.mp3',
      'gameOverMusic': 'Assets/Audio/backgroundmusic_game over.mp3',
      'winningMusic': 'Assets/Audio/background music_ending winning screen_We Found Love.mp3'
    };
    
    // Function to log audio message - modified to not display visually
    function logAudio(message) {
      console.log('%c AUDIO: ' + message, 'background: #222; color: #bada55');
      // No longer updating UI indicator
    }
    
    // Remove test button handler
    // audioTestBtn.addEventListener('click', function() { ... });
    
    // Super simple sound player - Audio folder only
    function playDirectSound(soundType) {
      // Check if music/sound is enabled
      if (!musicEnabled) {
        logAudio(`Sound muted, skipping: ${soundType}`);
        return;
      }
      
      const soundPath = soundFiles[soundType];
      if (!soundPath) {
        logAudio(`No path defined for sound type: ${soundType}`);
        return;
      }
      
      try {
        // Create a new audio element
        const sound = new Audio(soundPath);
        sound.volume = 1.0;
        
        // Play with proper error handling
        const playPromise = sound.play();
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              logAudio(`Playing ${soundType}`);
            })
            .catch(e => {
              logAudio(`Error playing ${soundType}: ${e.message}`);
            });
        }
        
        // Debug events
        sound.onended = () => logAudio(`${soundType} finished playing`);
        sound.onerror = (e) => {
          logAudio(`Error with ${soundType}: ${e.type}`);
          // Show more details about the error
          if (sound.error) {
            logAudio(`Error code: ${sound.error.code}, message: ${sound.error.message}`);
          }
        };
      } catch(e) {
        logAudio(`Exception with ${soundType}: ${e.message}`);
      }
    }
    
    // Simplified tryPlaySound function
    function tryPlaySound(sound) {
      // Map old sound names to new ones if needed
      let soundType = sound;
      if (sound === 'collect') soundType = 'collectBitcoin';
      
      // Simple direct play of valid sound types
      if (soundType === 'moltoBene' || 
          soundType === 'collectBitcoin' || 
          soundType === 'zap1' || 
          soundType === 'zap2' || 
          soundType === 'zap3') {
        playDirectSound(soundType);
      }
    }
    
    // Function to enable audio (keep this simple)
    function enableAudio() {
      if (!audioEnabled) {
        audioEnabled = true;
        logAudio("Audio enabled by user interaction");
        
        // Initialize audio context if needed (for modern browsers)
        if (window.AudioContext || window.webkitAudioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!window.audioContext) {
            window.audioContext = new AudioContext();
          }
        }
        
        // Play background music for the current screen
        if (!audioInitialized) {
          // Determine which music to play based on current screen
          if (gameOver) {
            playBackgroundMusic('gameOverMusic');
          } else if (gameActive) {
            playBackgroundMusic('gameMusic1');
          } else {
            playBackgroundMusic('menuMusic');
          }
          audioInitialized = true;
        }
      }
    }
    
    // Add event listeners to enable audio on any user interaction
    document.addEventListener('click', enableAudio);
    document.addEventListener('keydown', enableAudio);
    document.addEventListener('touchstart', enableAudio);
    
    // "Molto Bene!" exclamation system
    let moltoBeneSprite = null;
    
    // Create the Molto Bene sprite
    function createMoltoBeneSprite() {
      // Create a canvas for the text
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Try to load the image
      const img = new Image();
      img.onload = function() {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        if (moltoBeneSprite && moltoBeneSprite.material) {
          moltoBeneSprite.material.map.needsUpdate = true;
        }
      };
      img.onerror = function() {
        // Fallback if image doesn't load
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Molto Bene!', canvas.width/2, canvas.height/2);
        if (moltoBeneSprite && moltoBeneSprite.material) {
          moltoBeneSprite.material.map.needsUpdate = true;
        }
      };
      img.src = 'Assets/Visual/molto bene.png';
      
      // Create texture from canvas
      const texture = new THREE.CanvasTexture(canvas);
      
      // Create sprite material
      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        opacity: 0 // Start invisible
      });
      
      // Create sprite
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(150, 75, 1); // Reduced by 25% from 200x100 to 150x75
      sprite.visible = false;
      
      // Add to scene
      scene.add(sprite);
      
      return sprite;
    }
    
    // Initialize the Molto Bene sprite
    moltoBeneSprite = createMoltoBeneSprite();
    
    // Show "Molto Bene!" above player
    function showMoltoBene() {
      console.log("showMoltoBene called");
      
      // Play sound directly
      playDirectSound('moltoBene');
      
      if (!moltoBeneSprite) return;
      
      // Position above player
      moltoBeneSprite.position.set(
        playerContainer.position.x,
        playerContainer.position.y + 100, // Position above player
        5 // Make sure it's in front
      );
      
      // Make visible
      moltoBeneSprite.visible = true;
      moltoBeneSprite.material.opacity = 0;
      
      // Set animation data
      moltoBeneSprite.userData = {
        active: true,
        startTime: Date.now(),
        duration: 1500 // 1.5 seconds
      };
    }
    
    // Update "Molto Bene!" animation
    function updateMoltoBene() {
      if (!moltoBeneSprite || !moltoBeneSprite.userData.active) return;
      
      const elapsed = Date.now() - moltoBeneSprite.userData.startTime;
      const duration = moltoBeneSprite.userData.duration;
      
      if (elapsed >= duration) {
        // Animation complete
        moltoBeneSprite.visible = false;
        moltoBeneSprite.userData.active = false;
        return;
      }
      
      // Keep positioned above player
      moltoBeneSprite.position.x = playerContainer.position.x;
      moltoBeneSprite.position.y = playerContainer.position.y + 100;
      
      // Fade in/out animation
      let opacity = 1;
      
      // Fade in during first 20%
      if (elapsed < duration * 0.2) {
        opacity = elapsed / (duration * 0.2);
      } 
      // Fade out during last 30%
      else if (elapsed > duration * 0.7) {
        opacity = 1 - ((elapsed - duration * 0.7) / (duration * 0.3));
      }
      
      // Set opacity
      moltoBeneSprite.material.opacity = opacity;
    }

    // Spawning logic
    function spawnObject(type) {
      // For bank buildings, only spawn in city backgrounds (and not in Crypto Winter)
      if (type === 'building' && (!isCityBackground || inCryptoWinter)) {
        console.log("Prevented bank building spawn");
        return;
      }
      
      let texture = textureCache[type];
      
      // In Crypto Winter, use snow-themed enemies
      if (inCryptoWinter) {
        if (type === 'enemy') {
          texture = textureCache.snowEnemy;
        } else if (type === 'bear') {
          texture = textureCache.bearIdle; // Start with idle pose
        } else if (type === 'bear2') {
          texture = textureCache.bear2Idle; // Start with idle pose
        } else if (type === 'candle') {
          // Randomly choose between the two snow candles
          texture = Math.random() > 0.5 ? textureCache.snowCandle : textureCache.snowCandleShort;
        } else if (type === 'candleLong') {
          // Use snow candle but will override dimensions below
          texture = textureCache.snowCandle;
        }
      }
      
      // Scale factor for mobile devices (70% of desktop size)
      const scaleFactor = isMobilePortrait() ? 0.7 : 1.0;
      
      // Define sizes with fixed width-to-height ratios, scaled for device
      let width, height;
      
      if (type === 'pizza') {
        width = 60 * scaleFactor;
        height = 60 * scaleFactor;
      } else if (type === 'bitcoin') {
        width = 60 * scaleFactor;
        height = 60 * scaleFactor;
      } else if (type === 'enemy') {
        // Blue mutant / Snow mutant - match original image aspect ratio (~1.67:1)
        width = 250 * scaleFactor;
        height = 150 * scaleFactor;
      } else if (type === 'building') {
        // Bank building - make it much wider
        width = 240 * scaleFactor;
        height = 200 * scaleFactor;
      } else if (type === 'candle') {
        width = 80 * scaleFactor;
        height = 120 * scaleFactor;
      } else if (type === 'candleLong') {
        if (inCryptoWinter) {
          // Snow candle has ~0.65:1 aspect ratio (taller than wide)
          width = 100 * scaleFactor;
          height = 150 * scaleFactor;
        } else {
          width = 80 * scaleFactor;
          // Varying height for the long candles
          height = (200 + Math.random() * 300) * scaleFactor; // Between 200-500 pixels tall, scaled
        }
      } else if (type === 'bear') {
        // Bear #1 (bear_one_arm, bearstand) is taller than wide (~2:3 ratio) - 45% larger (25% + 20%)
        width = 216 * scaleFactor;
        height = 324 * scaleFactor;
      } else if (type === 'bear2') {
        // Bear #2 (bear, bearmid) is square (1:1 aspect ratio) - 25% larger
        width = 250 * scaleFactor;
        height = 250 * scaleFactor;
      }

      // Create material with proper transparency settings
      const material = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true,
        alphaTest: 0.1 // Helps with transparency
      });
      
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(width, height, 1);
      sprite.width = width;
      sprite.height = height;
      sprite.type = type; // Set type property
      sprite.userData = { isAggro: false }; // For bear enemy state tracking
      
      // Position logic
      let yPosition;
      if (type === 'building') {
        // Place buildings at the bottom of the screen, sitting on the ground
        yPosition = -window.innerHeight / 2 + sprite.height / 2 + 10; // +10 for ground height
      } else if (type === 'bear' || type === 'bear2') {
        // Place bears on the illustrated ground level (higher than screen bottom)
        yPosition = -window.innerHeight / 2 + sprite.height / 2 + 60; // Adjusted to match snow ground level
      } else if (type === 'candleLong') {
        // Position candle long at the top of the screen, with most of it visible
        yPosition = window.innerHeight / 2 - 50; // Just below the top edge
      } else {
        // Random position for other objects
        yPosition = Math.random() * window.innerHeight - window.innerHeight / 2;
      }
      
      sprite.position.set(window.innerWidth, yPosition, 0);
      scene.add(sprite);

      if (type === 'enemy' || type === 'candleLong') {
        enemies.push(sprite);
      } else if (type === 'bear' || type === 'bear2') {
        // Bears are ground obstacles like buildings
        obstacles.push(sprite);
      }
      else if (type === 'building' || type === 'candle') obstacles.push(sprite);
      else collectibles.push(sprite);
    }

    // Spawn timers
    let lastSpawn = 0;
    let lastCandleLongSpawn = 0; // Separate timer for candle long
    let enemySpawnChance = 0.18; // Increased from 0.12 to 0.18 for more enemies
    let candleLongSpawnChance = 0.05; // 5% chance to spawn a long candle
    
    function updateSpawns(time) {
      // Don't spawn anything if we're on the moon background
      if (isMoonBackground) {
        return; // No enemies or objects on the moon
      }
      
      // Don't spawn ANYTHING after igloo in Crypto Winter (background 4+ / index 3+)
      if (inCryptoWinter && (cryptoWinterCurrentBgIndex >= 3 || cryptoWinterEnding || greenCandleAudio)) {
        return; // Absolutely no spawning after igloo
      }

      // Verify current background before spawning
      const inCityNow = checkBackgroundVisibility();
      
      // Regular spawn logic - slower spawns in Crypto Winter for reduced difficulty
      const spawnInterval = inCryptoWinter ? 2.8 : 1.8; // Slower spawns in ice level
      if (time - lastSpawn > spawnInterval) {
        // Determine what to spawn
        const spawnRoll = Math.random();
        let typeToSpawn;
        
        // Lower enemy spawn chance in Crypto Winter
        const currentEnemySpawnChance = inCryptoWinter ? 0.10 : enemySpawnChance;
        if (spawnRoll < currentEnemySpawnChance) {
          typeToSpawn = 'enemy';
        } else {
          // First, determine available types based on current background
          let availableTypes;
          
          if (inCryptoWinter) {
            // No enemies after background 4 (igloo) - backgrounds 5 and 6 are enemy-free
            // Index 3 = background 4 (igloo), so >= 3 means after igloo starts
            if (cryptoWinterCurrentBgIndex >= 3 || cryptoWinterEnding) {
              // Don't spawn anything after igloo
              return;
            }
            // Crypto Winter - only candles and occasional bears - no pizzas or bitcoins
            // Reduced bear frequency for easier gameplay
            availableTypes = ['candle', 'candle', 'candle', 'candle', 'candle', 'bear', 'bear2'];
            console.log("In Crypto Winter: no pizzas or bitcoins");
          } else if (inCityNow) {
            // City background (Barcelona or New York) - include bank buildings
            // Reduced pizza frequency (now appears less often)
            availableTypes = ['bitcoin', 'bitcoin', 'bitcoin', 'bitcoin', 'pizza', 'building', 'building', 'candle', 'candle'];
            console.log("In city: can spawn bank buildings");
          } else {
            // Non-city background - exclude bank buildings
            // Reduced pizza frequency (now appears less often)
            availableTypes = ['bitcoin', 'bitcoin', 'bitcoin', 'bitcoin', 'pizza', 'candle', 'candle'];
            console.log("Not in city: no bank buildings");
          }
          
          typeToSpawn = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        }
        
        spawnObject(typeToSpawn);
        lastSpawn = time;
      }
      
      // Red candle long spawn logic - every 5-10 seconds on average (less frequent in Crypto Winter)
      const currentCandleLongChance = inCryptoWinter ? 0.02 : candleLongSpawnChance; // Lower in ice level
      const candleLongInterval = inCryptoWinter ? 8 : 5; // Longer wait in ice level
      if (time - lastCandleLongSpawn > candleLongInterval && Math.random() < currentCandleLongChance) {
        spawnObject('candleLong');
        lastCandleLongSpawn = time;
      }
    }

    // Collision detection
    function checkCollision(a, b) {
      // Define collision margin (percentage reduction from full size)
      // Higher values = smaller hitbox = less sensitive collisions
      const marginA = a.type === 'enemy' ? 0.4 : 0.3; // 40% margin for enemies, 30% for other objects
      const marginB = b.type === 'enemy' ? 0.4 : 0.3;
      
      // For the player (Rocket Pizza), use a specific margin
      const playerMarginX = 0.45; // 45% reduction horizontally
      const playerMarginY = 0.35; // 35% reduction vertically
      
      // Calculate reduced dimensions for sprite A
      let aWidthReduced, aHeightReduced, aPosX, aPosY;
      if (a === player) {
        aWidthReduced = a.width * (1 - playerMarginX);
        aHeightReduced = a.height * (1 - playerMarginY);
        aPosX = playerContainer.position.x; // Use container position
        aPosY = playerContainer.position.y; // Use container position
      } else {
        aWidthReduced = a.width * (1 - marginA);
        aHeightReduced = a.height * (1 - marginA);
        aPosX = a.position.x;
        aPosY = a.position.y;
      }
      
      // Calculate reduced dimensions for sprite B
      let bWidthReduced, bHeightReduced, bPosX, bPosY;
      if (b === player) {
        bWidthReduced = b.width * (1 - playerMarginX);
        bHeightReduced = b.height * (1 - playerMarginY);
        bPosX = playerContainer.position.x; // Use container position
        bPosY = playerContainer.position.y; // Use container position
      } else {
        bWidthReduced = b.width * (1 - marginB);
        bHeightReduced = b.height * (1 - marginB);
        bPosX = b.position.x;
        bPosY = b.position.y;
      }
      
      // Check if the reduced hitboxes intersect
      const hasCollision = (
        aPosX - aWidthReduced / 2 < bPosX + bWidthReduced / 2 &&
        aPosX + aWidthReduced / 2 > bPosX - bWidthReduced / 2 &&
        aPosY - aHeightReduced / 2 < bPosY + bHeightReduced / 2 &&
        aPosY + aHeightReduced / 2 > bPosY - bHeightReduced / 2
      );
      
      // Debug info on collision detection
      if (hasCollision) {
        console.log("DETAILED COLLISION DATA:");
        if (a === player) {
          console.log("Player hitbox:", {
            left: aPosX - aWidthReduced / 2,
            right: aPosX + aWidthReduced / 2,
            top: aPosY + aHeightReduced / 2,
            bottom: aPosY - aHeightReduced / 2,
            width: aWidthReduced,
            height: aHeightReduced
          });
        }
        if (b.type) {
          console.log(`${b.type} hitbox:`, {
            left: bPosX - bWidthReduced / 2,
            right: bPosX + bWidthReduced / 2,
            top: bPosY + bHeightReduced / 2,
            bottom: bPosY - bHeightReduced / 2,
            width: bWidthReduced,
            height: bHeightReduced
          });
        }
      }
      
      // NEW: Add more detailed collision logging for close calls
      const distance = Math.sqrt(Math.pow(aPosX - bPosX, 2) + Math.pow(aPosY - bPosY, 2));
      if (distance < 200) {
        console.log(`CLOSE OBJECT: Distance ${Math.round(distance)}px between player and ${b.type || 'object'}`);
        if (distance < 100) {
          console.log(`VERY CLOSE: ${b.type || 'object'} at (${bPosX}, ${bPosY}), player at (${aPosX}, ${aPosY})`);
          
          // Calculate overlap on each axis
          const overlapX = Math.min(aPosX + aWidthReduced/2, bPosX + bWidthReduced/2) - 
                          Math.max(aPosX - aWidthReduced/2, bPosX - bWidthReduced/2);
          const overlapY = Math.min(aPosY + aHeightReduced/2, bPosY + bHeightReduced/2) - 
                          Math.max(aPosY - aHeightReduced/2, bPosY - bHeightReduced/2);
                          
          console.log(`Overlap: X=${overlapX.toFixed(2)}, Y=${overlapY.toFixed(2)}`);
        }
      }
      
      return hasCollision;
    }
    
    // Helper function to visualize hitboxes (for debugging)
    function createHitboxVisualizer() {
      const hitboxMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      
      return {
        update: function(object) {
          // Remove old visualizer if it exists
          if (object.hitboxVisualizer) {
            scene.remove(object.hitboxVisualizer);
          }
          
          // Determine margins based on object type
          let margin;
          if (object === player) {
            const widthMargin = 0.45;
            const heightMargin = 0.35;
            const width = object.width * (1 - widthMargin);
            const height = object.height * (1 - heightMargin);
            
            // Create square geometry for the hitbox
            const geometry = new THREE.BufferGeometry();
            const points = [
              new THREE.Vector3(-width/2, -height/2, 0),
              new THREE.Vector3(width/2, -height/2, 0),
              new THREE.Vector3(width/2, height/2, 0),
              new THREE.Vector3(-width/2, height/2, 0),
              new THREE.Vector3(-width/2, -height/2, 0)
            ];
            geometry.setFromPoints(points);
            
            // Create the line
            const line = new THREE.Line(geometry, hitboxMaterial);
            line.position.copy(object.position);
            line.position.z = 1;
            
            // Store on object and add to scene
            object.hitboxVisualizer = line;
            scene.add(line);
          } else {
            margin = object.type === 'enemy' ? 0.4 : 0.3;
            const width = object.width * (1 - margin);
            const height = object.height * (1 - margin);
            
            // Create square geometry for the hitbox
            const geometry = new THREE.BufferGeometry();
            const points = [
              new THREE.Vector3(-width/2, -height/2, 0),
              new THREE.Vector3(width/2, -height/2, 0),
              new THREE.Vector3(width/2, height/2, 0),
              new THREE.Vector3(-width/2, height/2, 0),
              new THREE.Vector3(-width/2, -height/2, 0)
            ];
            geometry.setFromPoints(points);
            
            // Create the line
            const line = new THREE.Line(geometry, hitboxMaterial);
            line.position.copy(object.position);
            line.position.z = 1;
            
            // Store on object and add to scene
            object.hitboxVisualizer = line;
            scene.add(line);
          }
        }
      };
    }
    
    // Uncomment this line to enable hitbox visualization for debugging
    // const hitboxVisualizer = createHitboxVisualizer();

    // Bonus timers
    let laserBonusTimer = 0;

    // Variables to track completion of the final background
    let hasCompletedFinalBackground = false;
    let finalBackgroundIndex = backgroundFiles.length - 1; // Index of the final background
    let videoPlaying = false;
    
    // Function to check background completion
    function checkBackgroundCompletion() {
      // Only check if we haven't completed the final background yet and the video hasn't played
      if (!hasCompletedFinalBackground && !videoPlaying && !videoHasPlayed && !gameOver) {
        // Check if the final background is completed (off-screen to the left)
        const finalBackground = backgrounds.find(bg => bg.userData && bg.userData.fileIndex === finalBackgroundIndex);
        
        if (finalBackground && finalBackground.position.x < -backgroundWidth) {
          console.log("Final background completed! Playing ending video...");
          hasCompletedFinalBackground = true;
          playEndingVideo();
        }
      }
    }
    
    // Function to play the ending video
    function playEndingVideo() {
      // Prevent playing the video if it has already been played
      if (videoHasPlayed || gameOver) {
        console.log("Video has already played or game is over, not playing again");
        return;
      }
      
      // Set the permanent flag that video has played
      videoHasPlayed = true;
      
      // Pause the game
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Stop background music
      stopBackgroundMusic();
      
      // Get video element
      const video = document.getElementById('endingVideo');
      
      // Show the video (initially invisible because overlay is still faded to black)
      video.style.display = 'block';
      
      // Set flag
      videoPlaying = true;
      hasCompletedFinalBackground = true;
      
      // After a short delay, fade from black to reveal the video
      setTimeout(() => {
        // Fade out the black overlay to reveal video
        fadeOverlay.style.opacity = '0';
        
        // Play the video
        const playPromise = video.play();
        if (playPromise !== undefined) {
          playPromise.catch(error => {
            console.error("Error playing video:", error);
            // In case of error, skip to game over
            endGameAfterVideo();
          });
        }
        
        // Add a safety timeout to ensure the video doesn't get stuck
        // This will trigger if the onended event doesn't fire properly
        setTimeout(() => {
          if (videoPlaying) {
            console.log("Video safety timeout triggered - force ending video");
            endGameAfterVideo();
          }
        }, 30000); // 30 second safety timeout
      }, 1000);
      
      // When video ends, show game over screen
      video.onended = function() {
        console.log("Video ended, showing game over screen");
        endGameAfterVideo();
      };
    }
    
    // Function to end the game after video
    function endGameAfterVideo() {
      // Prevent multiple calls
      if (!videoPlaying) return;
      
      console.log("Ending game after video");
      
      // Hide the video
      const video = document.getElementById('endingVideo');
      video.pause(); // Ensure video stops playing
      video.currentTime = 0; // Reset video position
      video.style.display = 'none';
      
      // Update flags
      videoPlaying = false;
      hasCompletedFinalBackground = true;  // Ensure we don't trigger the video again
      videoHasPlayed = true; // Set the permanent flag that video has played
      
      // Reset fade overlay
      fadeOverlay.style.opacity = '0';
      fadeInProgress = false;
      
      // Handle game over - force game over even if player has lives left, and mark as a win
      endGame(true, true);
    }

    // Game loop
    function animate(time) {
      // Safety check: only run if game is actually active
      if (!gameActive || gameOver) {
        return;
      }
      
      // If respawning, just render the scene but don't update game state
      if (isRespawning) {
        renderer.render(scene, camera);
        animationFrameId = requestAnimationFrame(animate);
        return;
      }
      
      if (gameStartTime === 0) {
        gameStartTime = time;
        lastFrameTime = time;
        // Give initial upward velocity at start
        playerVelocity = flapStrength;
        // Set normal game speed for backgrounds
        backgroundSpeed = 2;
      }

      // Calculate delta time for frame-rate independent physics
      const deltaTime = time - lastFrameTime;
      lastFrameTime = time;
      const deltaFactor = deltaTime / targetFrameTime; // 1.0 at 60fps, 0.5 at 120fps, etc.

      // Update player with frame-rate independent physics
      // Use reduced gravity in ice level until first tap (slow-fall grace period)
      const effectiveGravity = (inCryptoWinter && !cryptoWinterFirstTap) ? gravity * 0.3 : gravity;
      playerVelocity -= effectiveGravity * deltaFactor;
      // Cap fall speed at terminal velocity (prevents infinite acceleration)
      // Use slower terminal velocity during grace period too
      const effectiveTerminalVelocity = (inCryptoWinter && !cryptoWinterFirstTap) ? terminalVelocity * 0.3 : terminalVelocity;
      if (playerVelocity < effectiveTerminalVelocity) {
        playerVelocity = effectiveTerminalVelocity;
      }
      playerContainer.position.y += playerVelocity * deltaFactor; // Update container position instead of sprite
      
      // Only check boundaries after a short grace period
      if (time - gameStartTime > 1000) {
        // Check bottom boundary - keep this sensitive to provide floor challenge
        const bottomBoundary = -window.innerHeight / 2 + 20;
        if (playerContainer.position.y < bottomBoundary) {
          console.log("Hit bottom boundary");
          console.log(`Player Y: ${playerContainer.position.y}, Bottom boundary: ${bottomBoundary}`);
          
          // Check if on Oslo level (index 8) OR first background (index 0 for testing) and not already in Crypto Winter - trigger hidden level!
          // TODO: Remove index 0 check after testing
          if ((currentBackgroundIndex === 8 || currentBackgroundIndex === 0) && !inCryptoWinter && !cryptoWinterIntroPlaying) {
            console.log("HIDDEN LEVEL DISCOVERED: Falling through floor at background " + currentBackgroundIndex);
            startCryptoWinterIntro();
            return;
          }
          
          endGame(false, false, "bottom_boundary");
          return;
        } else if (playerContainer.position.y < bottomBoundary + 50) {
          // NEW: Warning when getting close to bottom boundary
          console.log(`WARNING: Close to bottom boundary! Player Y: ${playerContainer.position.y}, Bottom: ${bottomBoundary}`);
        }
        
        // Check top boundary - only trigger when completely off-screen
        // Calculate how far the player can go before being completely off-screen
        // Player.position.y is at the center, so we need to add half height to get to the bottom edge
        const playerBottomEdge = playerContainer.position.y - player.height / 2;
        const screenTopEdge = window.innerHeight / 2;
        
        // Only die when the bottom edge of the player is above the top edge of the screen
        if (playerBottomEdge > screenTopEdge) {
          console.log("Completely beyond top boundary");
          console.log(`Player bottom edge: ${playerBottomEdge}, Screen top edge: ${screenTopEdge}`);
          endGame(false, false, "top_boundary");
          return;
        } else if (playerBottomEdge > screenTopEdge - 50) {
          // NEW: Warning when getting close to top boundary
          console.log(`WARNING: Close to top boundary! Player bottom: ${playerBottomEdge}, Top: ${screenTopEdge}`);
        }
      }

      // Update background with continuous scrolling (frame-rate independent)
      const adjustedSpeed = backgroundSpeed * deltaFactor;
      if (inCryptoWinter) {
        updateCryptoWinterBackgrounds(adjustedSpeed);
        // Update snow particles and wind effects (only if green candle not showing)
        if (!greenCandleSprite) {
          updateSnowParticles();
          applyWindToPlayer();
        }
        // Update foreground tree
        updateForegroundTree();
        // Check if player flies into sunlight to exit
        if (greenCandleSprite) {
          checkSunlightExit();
        }
      } else {
        updateBackgrounds(adjustedSpeed);
        updateForegroundBush(); // Update bush that hides Jaipur seam
        updateForegroundSnowpile(); // Update snowpile that hides Oslo left seam
        updateForegroundSnowpileRight(); // Update snowpile that hides Oslo right seam
      }
      
      // Check if player has completed the final background
      if (!gameOver) {  // Only check if the game is not already over
        checkBackgroundCompletion();
      }
      
      // Update player texture based on laser count
      updatePlayerTexture();
      
      // Update laser beams and explosions
      updateLaserBeams();

      // Check if full power mode should end
      if (fullPowerMode) {
        if (Date.now() > fullPowerTimer) {
          console.log("FULL POWER MODE ENDED");
          fullPowerMode = false;
          // Reset laser count to zero after full power mode ends
          laserCount = 0;
          updatePlayerTexture(); // Update the player's eye glow texture
        } else {
          // Fire all lasers while in full power mode
          fireAllLasers();
        }
      }

      // Update collectibles
      for (let i = collectibles.length - 1; i >= 0; i--) {
        const c = collectibles[i];
        c.position.x -= 3;
        if (c.position.x < -window.innerWidth / 2) {
          scene.remove(c);
          collectibles.splice(i, 1);
        } else if (checkCollision(player, c)) {
          if (c.type === 'pizza') {
            // Pizza now gives retries
            retryCount++;
            updateRetryDisplay();
            score += 10; // Each pizza is still worth 10 points
            tryPlaySound('moltoBene');
            // Show "Molto Bene!"
            showMoltoBene();
            scene.remove(c);
            collectibles.splice(i, 1);
          } else if (c.type === 'bitcoin') {
            laserCount++;
            console.log("Bitcoin collected, new laserCount:", laserCount);
            tryPlaySound('collectBitcoin');
            scene.remove(c);
            collectibles.splice(i, 1);
            
            if (laserCount >= 3) {
              // Activate full power mode when 3rd bitcoin is collected
              activateFullPower();
            } else {
              // Just update the texture for normal laser power
              updatePlayerTexture();
            }
          }
        }
      }

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.position.x -= 5;
        
        if (e.position.x < -window.innerWidth / 2) {
          scene.remove(e);
          enemies.splice(i, 1);
        } else if (fullPowerMode && e.position.x < triggerX + 200) {
          // During full power, enemies are automatically destroyed when they get close
          createExplosion(e.position, 0xff3300);
          scene.remove(e);
          enemies.splice(i, 1);
          score += 20;
        } else if (e.position.x < triggerX && e.position.x > playerContainer.position.x && !fullPowerMode && !laserBonusActive) {
          // Only target enemies that are in front of the player (to the right)
          if (laserCount > 0) {
            // Always use the right-most available eye
            let eyeToUse;
            
            // Debug info
            console.log("Enemy target: Current laser count =", laserCount);
            
            // This ensures we use the right-most available eye based on laser count
            if (laserCount >= 3) {
              console.log("Using RIGHT eye (2)");
              eyeToUse = 2; // Right eye
            } else if (laserCount >= 2) {
              console.log("Using MIDDLE eye (1)");
              eyeToUse = 1; // Middle eye
            } else {
              console.log("Using LEFT eye (0)");
              eyeToUse = 0; // Left eye
            }
                        
            // Shoot laser from the specific eye
            shootLaserAt(e, eyeToUse);
            
            // Decrement laser count after shooting
            laserCount--;
            console.log("Laser count after shooting:", laserCount);
            
            updatePlayerTexture(); // Update the player's eye glow texture
            scene.remove(e);
            enemies.splice(i, 1);
            score += 20;
          } else if (checkCollision(player, e)) {
            console.log("COLLISION DETECTED: Player hit enemy at position:", e.position.x, e.position.y);
            console.log("Player position:", playerContainer.position.x, playerContainer.position.y);
            endGame(false, false, "enemy_collision");
            return; // Add explicit return to prevent further processing
          }
        } else if (checkCollision(player, e)) {
          console.log("COLLISION DETECTED: Player hit enemy at position:", e.position.x, e.position.y);
          console.log("Player position:", playerContainer.position.x, playerContainer.position.y);
          endGame(false, false, "enemy_collision");
          return; // Add explicit return to prevent further processing
        }
      }

      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.position.x -= 3;
        
        // Bear obstacle: swap texture when player approaches
        if (o.type === 'bear' && inCryptoWinter) {
          const distanceToPlayer = o.position.x - playerContainer.position.x;
          const approachDistance = 400; // Distance at which bear becomes aggressive
          
          if (distanceToPlayer < approachDistance && !o.userData.isAggro) {
            // Player is approaching - switch to aggressive pose
            o.material.map = textureCache.bearAggro;
            o.material.needsUpdate = true;
            o.userData.isAggro = true;
            playDirectSound('bearRoar1'); // Play polar bear roar #1
            console.log("Bear spotted player! Switching to aggressive pose");
          }
        }
        
        // Bear2 obstacle: swap texture when player approaches
        if (o.type === 'bear2' && inCryptoWinter) {
          const distanceToPlayer = o.position.x - playerContainer.position.x;
          const approachDistance = 400; // Distance at which bear becomes aggressive
          
          if (distanceToPlayer < approachDistance && !o.userData.isAggro) {
            // Player is approaching - switch to aggressive pose
            o.material.map = textureCache.bear2Aggro;
            o.material.needsUpdate = true;
            o.userData.isAggro = true;
            playDirectSound('bearRoar2'); // Play polar bear roar #2
            console.log("Bear2 spotted player! Switching to aggressive pose");
          }
        }
        
        if (o.position.x < -window.innerWidth / 2) {
          scene.remove(o);
          obstacles.splice(i, 1);
        } else if (fullPowerMode && o.position.x < triggerX + 200) {
          // During full power, obstacles are automatically destroyed when they get close
          createExplosion(o.position, 0xff3300);
          scene.remove(o);
          obstacles.splice(i, 1);
          score += 20;
        } else if (o.position.x < triggerX && o.position.x > playerContainer.position.x && laserCount > 0 && !fullPowerMode && !laserBonusActive) {
          // Only target obstacles that are in front of the player (to the right)
          // Always use the right-most available eye
          let eyeToUse;
          
          // Debug info
          console.log("Obstacle target: Current laser count =", laserCount);
            
          // This ensures we use the right-most available eye based on laser count
          if (laserCount >= 3) {
            console.log("Using RIGHT eye (2)");
            eyeToUse = 2; // Right eye
          } else if (laserCount >= 2) {
            console.log("Using MIDDLE eye (1)");
            eyeToUse = 1; // Middle eye
          } else {
            console.log("Using LEFT eye (0)");
            eyeToUse = 0; // Left eye
          }
          
          // Shoot laser from the specific eye
          shootLaserAt(o, eyeToUse);
          
          // Decrement laser count after shooting
          laserCount--;
          console.log("Laser count after shooting:", laserCount);
          
          updatePlayerTexture(); // Update the player's eye glow texture
          scene.remove(o);
          obstacles.splice(i, 1);
          score += 20;
        } else if (checkCollision(player, o)) {
          console.log("COLLISION DETECTED: Player hit obstacle at position:", o.position.x, o.position.y);
          console.log("Player position:", playerContainer.position.x, playerContainer.position.y);
          console.log("Obstacle type:", o.type);
          endGame(false, false, "obstacle_collision");
          return; // Add explicit return to prevent further processing
        }
      }

      // Update bonuses
      if (laserBonusActive && time > laserBonusTimer) {
        laserBonusActive = false;
        laserCount = 0; // Reset laser count after bonus expires
        updatePlayerTexture(); // Update the player's eye glow texture
      }

      // Update score
      score += 0.1; // Base score increment
      
      // Update UI
      updateUI();

      // Spawn new objects
      updateSpawns(time / 1000);

      // Update the Molto Bene animation
      updateMoltoBene();

      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    // Input handling
    function onFlap(event) {
      // Don't respond to clicks on game over screen elements
      if (gameOver && (
        event.target.closest('#game-over') || 
        event.target.id === 'player-name-input' || 
        event.target.id === 'save-score-btn'
      )) {
        return; // Do nothing when clicking on game over screen elements
      }
      
      // Block ALL clicks when game over is shown, except for UI controls
      if (gameOver) {
        return; // Block clicks when game over
      }
      
      if (!gameActive) return;
      
      if (!gameOver) {
        // Mark first tap in ice level (ends slow-fall grace period)
        if (inCryptoWinter && !cryptoWinterFirstTap) {
          cryptoWinterFirstTap = true;
          console.log("Ice level: First tap - normal gravity activated");
        }
        playerVelocity = flapStrength;
      } else {
        restartGame();
      }
    }
    window.addEventListener('click', onFlap);
    window.addEventListener('touchstart', onFlap);
    window.addEventListener('keydown', function(e) {
      // Prevent space key from triggering flap when input field is focused
      if (document.activeElement === document.getElementById('player-name-input') && e.code === 'Space') {
        return;
      }
      if (e.code === 'Space') onFlap(e);
      
      // EMERGENCY EXIT: Press Escape to force exit Crypto Winter
      if (e.code === 'Escape' && (inCryptoWinter || bonusScreenActive)) {
        console.log("!!! EMERGENCY EXIT FROM CRYPTO WINTER (Escape pressed) !!!");
        
        // Stop any audio first
        if (greenCandleAudio) {
          greenCandleAudio.pause();
          greenCandleAudio = null;
        }
        if (cryptoWinterWindAudio) {
          cryptoWinterWindAudio.pause();
          cryptoWinterWindAudio = null;
        }
        
        // Use force recovery for maximum reliability
        forceRecoverFromCryptoWinter();
      }
    });
    
    // Add initialization for game over UI elements
    document.addEventListener('DOMContentLoaded', function() {
      // Add event listeners to game over elements to prevent propagation
      const gameOverElement = document.getElementById('game-over');
      gameOverElement.addEventListener('click', function(e) {
        e.stopPropagation();
      });
      
      document.getElementById('save-score-btn').addEventListener('click', function(e) {
        e.stopPropagation();
        savePlayerScore();
      });
      
      // Prevent the input field from triggering flap
      document.getElementById('player-name-input').addEventListener('click', function(e) {
        e.stopPropagation();
      });
      
      document.getElementById('player-name-input').addEventListener('keydown', function(e) {
        // Prevent keypresses in the input from triggering game actions
        e.stopPropagation();
      });
    });

    // Game over
    function endGame(forceGameOver = false, isVictory = false, reason = "unknown") {
      console.log(`============ GAME OVER ============`);
      console.log(`Reason: ${reason}`);
      console.log(`Force game over: ${forceGameOver}`);
      console.log(`Is victory: ${isVictory}`);
      console.log(`Player position: (${playerContainer.position.x}, ${playerContainer.position.y})`);
      console.log(`Retries remaining: ${retryCount}`);
      console.log(`Current score: ${score}`);
      console.log(`Current background: ${currentBackgroundIndex}`);
      console.log(`Active enemies: ${enemies.length}`);
      console.log(`Active obstacles: ${obstacles.length}`);
      console.log(`Active collectibles: ${collectibles.length}`);
      
      // NEW: More detailed debug information
      console.log(`DETAILED DEATH ANALYSIS:`);
      console.log(`Player velocity: ${playerVelocity}`);
      console.log(`Window height: ${window.innerHeight}`);
      console.log(`Top boundary: ${window.innerHeight / 2}`);
      console.log(`Bottom boundary: ${-window.innerHeight / 2 + 20}`);
      
      // List all nearby enemies
      console.log(`Nearby enemies:`);
      enemies.forEach((enemy, i) => {
        const distance = Math.sqrt(
          Math.pow(enemy.position.x - playerContainer.position.x, 2) +
          Math.pow(enemy.position.y - playerContainer.position.y, 2)
        );
        if (distance < 300) {
          console.log(`Enemy ${i}: position (${enemy.position.x}, ${enemy.position.y}), distance: ${distance}`);
        }
      });
      
      // List all nearby obstacles
      console.log(`Nearby obstacles:`);
      obstacles.forEach((obstacle, i) => {
        const distance = Math.sqrt(
          Math.pow(obstacle.position.x - playerContainer.position.x, 2) +
          Math.pow(obstacle.position.y - playerContainer.position.y, 2)
        );
        if (distance < 300) {
          console.log(`Obstacle ${i}: type ${obstacle.type}, position (${obstacle.position.x}, ${obstacle.position.y}), distance: ${distance}`);
        }
      });
      console.log(`==================================`);
      
      if (retryCount > 0 && !forceGameOver) {
        // If we have retries and not forcing game over, use one and respawn
        respawnPlayer();
      } else {
        // No retries left or forcing game over, go to game over screen
        gameOver = true;
        backgroundSpeed = 0.2; // Slow down background
        
        // Switch music based on victory or defeat
        stopBackgroundMusic();
        if (isVictory) {
          // Play winning music for victory screen
          playBackgroundMusic('winningMusic');
        } else {
          // Play regular game over music for defeat
          playBackgroundMusic('gameOverMusic');
        }
        
        // Show final score on game over screen
        const finalScore = Math.floor(score);
        document.getElementById('final-score').textContent = finalScore;
        
        // Enable name input for new score
        document.getElementById('player-name-form').style.display = 'block';
        
        // Store current score temporarily for the save function
        localStorage.setItem('tempScore', finalScore.toString());
        console.log("Stored temp score:", finalScore);
        
        // Record death reason in game stats if using analytics
        try {
          trackGameEvent('game_end_detailed', {
            player_id: getOrCreatePlayerId(),
            session_id: sessionStorage.getItem('current_session_id'),
            score: finalScore,
            death_reason: reason,
            victory: isVictory,
            player_position_x: playerContainer.position.x,
            player_position_y: playerContainer.position.y,
            background_index: currentBackgroundIndex
          });
        } catch (e) {
          console.error("Error recording death stats:", e);
        }
        
        // Show current leaderboard without adding new score yet
        displayLeaderboard();
        
        // Show game over screen with appropriate title based on victory or defeat
      document.getElementById('game-over').style.display = 'block';
        
        // Change the title image based on win/loss condition
        const gameOverImg = document.querySelector('#game-over img');
        if (isVictory) {
          // Use the GPP.png image for victory screen
          if (gameOverImg) {
            // Set the image source first
            gameOverImg.src = "Assets/Visual/GPP.png";
            gameOverImg.alt = "To The Moon!";
            gameOverImg.classList.add('victory');
            
            // Create a hyperlink around the image
            const parentElement = gameOverImg.parentNode;
            
            // Check if the image is not already wrapped in a link
            if (parentElement.tagName !== 'A') {
              // Create the anchor element
              const linkElement = document.createElement('a');
              linkElement.href = "https://globalpizza.party/"; // Set the target URL
              linkElement.target = "_blank"; // Open in new tab
              linkElement.style.display = "block";
              linkElement.style.cursor = "pointer";
              
              // Insert the link before the image
              parentElement.insertBefore(linkElement, gameOverImg);
              
              // Move the image inside the link
              linkElement.appendChild(gameOverImg);
            }
            
            // Remove any text overlay if it exists
            const existingOverlay = document.querySelector('#game-over .text-overlay');
            if (existingOverlay) {
              existingOverlay.remove();
            }
          }
        } else {
          // Reset to default game over image
          if (gameOverImg) {
            // If the image is wrapped in a link, unwrap it
            const parentElement = gameOverImg.parentNode;
            if (parentElement.tagName === 'A') {
              const grandParentElement = parentElement.parentNode;
              grandParentElement.insertBefore(gameOverImg, parentElement);
              
              // Remove the link element and any added text
              parentElement.remove();
            }
            
            // Set the game over image
            gameOverImg.src = "Assets/Visual/Game Over.png";
            gameOverImg.alt = "Game Over";
            gameOverImg.classList.remove('victory');
            
            // Remove any text overlay if it exists
            const existingOverlay = document.querySelector('#game-over .text-overlay');
            if (existingOverlay) {
              existingOverlay.remove();
            }
          }
        }
        
        document.getElementById('instructions').style.display = 'none';
        
        // Stop animation frame to prevent further updates
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        
        // Mark game as inactive
        gameActive = false;
        
        // Start the menu render loop for background animation
        startRenderLoop();
      }
    }
    
    // Sanitize HTML to prevent XSS attacks
    function sanitizeHTML(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    // ============================================
    // SESSION TRACKING & HEARTBEAT SYSTEM
    // ============================================
    
    // Create a new session when game starts
    async function createGameSession() {
      try {
        const { data: session, error } = await supabaseClient
          .from('game_sessions')
          .insert([{
            player_id: getOrCreatePlayerId(),
            heartbeat_count: 0
          }])
          .select()
          .single();
        
        if (error) {
          console.error("Failed to create session:", error);
          return null;
        }
        
        currentSessionId = session.id;
        heartbeatCount = 0;
        console.log("✅ Session created:", currentSessionId);
        return session;
      } catch (err) {
        console.error("Error creating session:", err);
        return null;
      }
    }
    
    // Send heartbeat to server
    async function sendHeartbeat() {
      if (!currentSessionId || !gameActive || gameOver) return;
      
      try {
        heartbeatCount++;
        
        const { error } = await supabaseClient
          .from('game_sessions')
          .update({
            heartbeat_count: heartbeatCount,
            last_heartbeat: new Date().toISOString()
          })
          .eq('id', currentSessionId);
        
        if (error) {
          console.error("Heartbeat failed:", error);
        } else {
          console.log(`💓 Heartbeat ${heartbeatCount} sent`);
        }
      } catch (err) {
        console.error("Error sending heartbeat:", err);
      }
    }
    
    // Start heartbeat interval
    function startHeartbeat() {
      // Clear any existing interval
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
      }
      
      // Send heartbeat every 10 seconds
      heartbeatInterval = setInterval(sendHeartbeat, 10000);
      console.log("💓 Heartbeat system started (10 second interval)");
    }
    
    // Stop heartbeat interval
    function stopHeartbeat() {
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
        console.log("💓 Heartbeat system stopped");
      }
    }
    
    // Mark session as complete
    async function completeGameSession() {
      if (!currentSessionId) return;
      
      try {
        const { error } = await supabaseClient
          .from('game_sessions')
          .update({ active: false })
          .eq('id', currentSessionId);
        
        if (error) {
          console.error("Failed to complete session:", error);
        } else {
          console.log("✅ Session completed");
        }
      } catch (err) {
        console.error("Error completing session:", err);
      }
    }
    
    // Save player score with name
    function savePlayerScore() {
      let playerName = document.getElementById('player-name-input').value.trim() || 'Anon';
      
      // Strip any HTML tags and limit length
      playerName = sanitizeHTML(playerName).substring(0, 15);
      
      // If name becomes empty after sanitization, use default
      if (!playerName || playerName.length === 0) {
        playerName = 'Anon';
      }
      
      const finalScore = parseInt(localStorage.getItem('tempScore') || '0');
      const sessionDuration = Math.floor((Date.now() - gameStartTimestamp) / 1000); // in seconds
      
      console.log(`Saving score for ${playerName}: ${finalScore} (session: ${sessionDuration}s)`);
      
      // Hide the name input form after saving
      document.getElementById('player-name-form').style.display = 'none';
      
      // Reset any existing leaderboard data if it's not in correct format
      const existingData = localStorage.getItem('bitcoinPizzaLeaderboard');
      if (existingData) {
        try {
          const parsed = JSON.parse(existingData);
          if (!Array.isArray(parsed) || parsed.length > 0 && (!parsed[0].name || parsed[0].score === undefined)) {
            console.log("Resetting corrupted leaderboard data");
            localStorage.removeItem('bitcoinPizzaLeaderboard');
          }
        } catch (e) {
          console.error("Error parsing leaderboard data:", e);
          localStorage.removeItem('bitcoinPizzaLeaderboard');
        }
      }
      
      // Update leaderboard with name and score
      updateLeaderboard(playerName, finalScore);
    }
    
    // Leaderboard functionality
    function updateLeaderboard(playerName, newScore) {
      console.log(`Updating leaderboard with ${playerName}: ${newScore}`);
      
      // Get stored leaderboard or create empty array
      let leaderboard = [];
      try {
        const stored = localStorage.getItem('bitcoinPizzaLeaderboard');
        if (stored) {
          leaderboard = JSON.parse(stored);
          if (!Array.isArray(leaderboard)) {
            console.log("Stored leaderboard is not an array, resetting");
            leaderboard = [];
          }
        }
      } catch (e) {
        console.error("Error loading leaderboard:", e);
      }
      
      console.log("Current leaderboard:", leaderboard);
      
      // Add new score with name
      const newEntry = {
        name: playerName,
        score: newScore
      };
      console.log("Adding new entry:", newEntry);
      leaderboard.push(newEntry);
      
      // Sort in descending order by score
      leaderboard.sort((a, b) => {
        // Ensure we're comparing numbers
        const scoreA = typeof a.score === 'number' ? a.score : 0;
        const scoreB = typeof b.score === 'number' ? b.score : 0;
        return scoreB - scoreA;
      });
      
      // Limit to top 5
      leaderboard = leaderboard.slice(0, 5);
      console.log("Sorted and trimmed leaderboard:", leaderboard);
      
      // Save back to localStorage
      localStorage.setItem('bitcoinPizzaLeaderboard', JSON.stringify(leaderboard));
      
      // Display updated leaderboard
      displayLeaderboard(playerName, newScore);
    }
    
    // Display leaderboard
    function displayLeaderboard(highlightName, highlightScore) {
      console.log("Displaying leaderboard, highlighting:", highlightName, highlightScore);
      
      // Get stored leaderboard
      let leaderboard = [];
      try {
        const stored = localStorage.getItem('bitcoinPizzaLeaderboard');
        if (stored) {
          leaderboard = JSON.parse(stored);
          if (!Array.isArray(leaderboard)) {
            console.log("Stored leaderboard is not an array for display");
            leaderboard = [];
          }
        }
      } catch (e) {
        console.error("Error loading leaderboard for display:", e);
      }
      
      console.log("Display leaderboard data:", leaderboard);
      
      // Update display
      const list = document.getElementById('leaderboard-list');
      list.innerHTML = ''; // Clear previous entries
      
      // If leaderboard is empty, add placeholder entries
      if (leaderboard.length === 0) {
        for (let i = 0; i < 5; i++) {
          const li = document.createElement('li');
          li.innerHTML = `
            <span class="rank">#${i + 1}</span>
            <span class="name">---</span>
            <span class="score">0</span>
          `;
          list.appendChild(li);
        }
        return;
      }
      
      // Add each entry to the list
      leaderboard.forEach((entry, index) => {
        // Ensure entry has correct properties
        const name = entry && typeof entry.name === 'string' ? entry.name : '---';
        const score = entry && typeof entry.score === 'number' ? entry.score : 0;
        
        const li = document.createElement('li');
        li.innerHTML = `
          <span class="rank">#${index + 1}</span>
          <span class="name">${sanitizeHTML(name)}</span>
          <span class="score">${score}</span>
        `;
        
        // Highlight the new score if it matches
        if (highlightName && name === highlightName && score === highlightScore) {
          li.classList.add('highlight');
        }
        
        list.appendChild(li);
      });
    }
    
    // New function to show the start screen
    function showStartScreen() {
      // Hide game over screen
      document.getElementById('game-over').style.display = 'none';
      
      // Show start screen
      document.getElementById('start-screen').style.display = 'flex';
      
      // Mark game as inactive
      gameActive = false;
      
      // Stop gameplay animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Switch to menu music
      stopBackgroundMusic();
      playBackgroundMusic('menuMusic');
      
      // Reset game state
      resetGameState();
      
      // Reset background positions to ensure we start from the beginning
      resetBackgroundPositions();
      
      // Set slow background speed for menu
      backgroundSpeed = 0.5;
      
      // Start the menu render loop
      startRenderLoop();
    }
    
    // Reset game state without starting animation
    function resetGameState() {
      // Stop heartbeats if active
      stopHeartbeat();
      
      // Reset all game variables
      gameOver = false;
      isRespawning = false;
      score = 0;
      retryCount = 0;
      updateRetryDisplay();
      laserCount = 0;
      laserBonusActive = false;
      const playerXPosition = getPlayerXPosition();
      playerContainer.position.set(playerXPosition, 0, 0); // Use responsive position
      playerVelocity = 0;
      gameStartTime = 0;
      backgroundSpeed = 0.5; // Slow for start screen
      
      // Reset Crypto Winter hidden level flags
      inCryptoWinter = false;
      cryptoWinterIntroPlaying = false;
      if (cryptoWinterAudio) {
        cryptoWinterAudio.pause();
        cryptoWinterAudio = null;
      }
      if (cryptoWinterWindAudio) {
        cryptoWinterWindAudio.pause();
        cryptoWinterWindAudio = null;
      }
      
      // Clean up Crypto Winter ending
      cryptoWinterEnding = false;
      cryptoWinterCurrentBgIndex = 0;
      if (greenCandleAudio) {
        greenCandleAudio.pause();
        greenCandleAudio = null;
      }
      if (greenCandleSprite) {
        scene.remove(greenCandleSprite);
        greenCandleSprite = null;
      }
      if (sunlightOverlay) {
        sunlightOverlay.remove();
        sunlightOverlay = null;
      }
      
      // Clean up Crypto Winter backgrounds and restore regular backgrounds
      if (cryptoWinterBackgrounds.length > 0) {
        cryptoWinterBackgrounds.forEach(bg => scene.remove(bg));
        cryptoWinterBackgrounds.length = 0;
        // Clear snow particles
        clearSnowParticles();
        // Restore regular backgrounds
        setupBackgrounds();
      }
      
      // Reset session tracking
      currentSessionId = null;
      heartbeatCount = 0;
      
      // Reset player texture and size
      updatePlayerTexture();
      const playerSizeObj = getPlayerSize();
      player.scale.set(playerSizeObj.width, playerSizeObj.height, 1);
      player.width = playerSizeObj.width;
      player.height = playerSizeObj.height;
      
      // Remove all game objects
      enemies.forEach(e => scene.remove(e));
      obstacles.forEach(o => scene.remove(o));
      collectibles.forEach(c => scene.remove(c));
      enemies.length = 0;
      obstacles.length = 0;
      collectibles.length = 0;
      
      // Hide/reset foreground elements (bush and snowpiles)
      if (foregroundBush) {
        foregroundBush.visible = false;
      }
      foregroundBushTriggered = false;
      if (foregroundSnowpile) {
        foregroundSnowpile.visible = false;
      }
      if (foregroundSnowpileRight) {
        foregroundSnowpileRight.visible = false;
      }
      
      // Update UI
      updateUI();
    }
    
    // Restart game
    async function restartGame() {
      console.log("🔄 Restarting game...");
      
      // CRITICAL: Set game as active FIRST to prevent render loop from continuing
      gameActive = true;
      gameOver = false;
      
      // Clear any pending game animation frame first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Stop the menu render loop if it's running (will now exit immediately due to gameActive check)
      stopRenderLoop();
      
      // Small delay to let any queued frames exit
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Stop any existing heartbeat
      stopHeartbeat();
      
      // Stop any existing session heartbeat (analytics)
      if (sessionHeartbeatInterval) {
        clearInterval(sessionHeartbeatInterval);
        sessionHeartbeatInterval = null;
      }
      
      // Hide any UI overlays
      document.getElementById('game-over').style.display = 'none';
      document.getElementById('respawn-message').style.display = 'none';
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('instructions').style.display = 'block';
      
      // Reset game state
      resetGameState();
      
      // Reset player position
      const playerXPosition = getPlayerXPosition();
      playerContainer.position.set(playerXPosition, 0, 0); // Use responsive position
      playerVelocity = flapStrength; // Give an initial upward boost
      
      // Reset background positions to ensure proper scroll restart
      resetBackgroundPositions();
      
      // Reset time and speed values
      gameStartTime = 0;
      backgroundSpeed = 2;
      
      // Reset analytics timestamp
      gameStartTimestamp = Date.now();
      
      // Make sure player texture is updated
      updatePlayerTexture();
      
      // Create new session and start heartbeats
      await createGameSession();
      startHeartbeat();
      
      // Reinitialize analytics for the new game session
      const analytics = initializeAnalytics();
      trackGameEvent('game_restart', {
        player_id: analytics.playerId,
        session_id: analytics.sessionId,
        current_scene: currentBackgroundIndex
      });
      
      // Start animation loop
      animationFrameId = requestAnimationFrame(animate);
      
      console.log("✅ Game restarted successfully");
    }
    
    // Function to reset background positions
    function resetBackgroundPositions() {
      console.log("Resetting background positions...");
      
      // Force background scrolling to stop
      backgroundSpeed = 0;
      
      // Ensure backgrounds are properly spaced
      for (let i = 0; i < backgrounds.length; i++) {
        if (i === 0) {
          // First background should be centered on screen
          backgrounds[i].position.x = 0;
        } else {
          // Position subsequent backgrounds to the right
          backgrounds[i].position.x = i * backgroundWidth;
        }
        console.log(`Background ${i}: position set to ${backgrounds[i].position.x}`);
      }
      
      // Force the first background to be visible and current
      currentBackgroundIndex = 0;
      
      // Update which background is currently visible
      checkBackgroundVisibility();
    }

    // Start the render loop without gameplay (for menu/game over screens)
    function startRenderLoop() {
      // Stop any existing render loop first
      if (masterLoopId) {
        cancelAnimationFrame(masterLoopId);
        masterLoopId = null;
      }
      
      // Don't start if game is already active
      if (gameActive) {
        console.log("🚫 Cannot start render loop - game is active");
        return;
      }
      
      function renderLoop() {
        // Safety check: only continue if game is not active
        if (gameActive) {
          return;
        }
        
        // Ensure background is visible
        ensureBackgroundsVisible();
        
        // Animate background slowly for visual effect
        updateBackgrounds(0.5);
        
        renderer.render(scene, camera);
        masterLoopId = requestAnimationFrame(renderLoop);
      }
      
      console.log("▶️ Render loop started");
      masterLoopId = requestAnimationFrame(renderLoop);
    }
    
    // Stop the render loop
    function stopRenderLoop() {
      if (masterLoopId) {
        cancelAnimationFrame(masterLoopId);
        masterLoopId = null;
        console.log("🛑 Render loop stopped");
      }
    }
    
    // Initialize the scene
    startRenderLoop();
    
    // Start game button - remove potentially conflicting handler
    // document.getElementById('start-button').addEventListener('click', startGame);
    
    async function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      gameActive = true;
      
      // Stop the menu render loop
      stopRenderLoop();
      
      // Create session and start heartbeat tracking
      await createGameSession();
      startHeartbeat();
      
      // Stop menu music and play gameplay music
      stopBackgroundMusic();
      playGameplayMusic();
      
      // Try to enable audio when game starts
      enableAudio();
      
      // Ensure backgrounds are properly positioned before starting game
      ensureBackgroundsVisible();
      backgroundSpeed = 2;
      
      // Reset timing for clean delta time calculation
      gameStartTime = 0;
      lastFrameTime = 0;
      
      updatePlayerTexture(); // Ensure correct player texture is set
      
      animationFrameId = requestAnimationFrame(animate);
    }

    // Function to activate full power mode
    function activateFullPower() {
      console.log("ACTIVATING FULL POWER MODE!");
      fullPowerMode = true;
      fullPowerTimer = Date.now() + fullPowerDuration;
      
      // Clear existing enemies for dramatic effect
      enemies.forEach(e => {
        // Create explosion at enemy position
        createExplosion(e.position, 0xff3300);
        scene.remove(e);
      });
      enemies.length = 0;
      
      // Update player texture to full power
      updatePlayerTexture();
      
      // Play all three zap sounds for dramatic effect
      setTimeout(() => playDirectSound('zap1'), 100);
      setTimeout(() => playDirectSound('zap2'), 300);
      setTimeout(() => playDirectSound('zap3'), 500);
    }

    // Function to fire all three lasers during full power mode
    function fireAllLasers() {
      // Don't fire too frequently
      const now = Date.now();
      if (now < lastLaserFireTime + laserFireInterval) return;
      
      lastLaserFireTime = now;
      
      // Fire random lasers for visual effect when no target is available
      if (enemies.length === 0 && obstacles.length === 0) {
        // Create random beam directions for visual effect
        for (let i = 0; i < 3; i++) {
          // Create a fake target ahead of the player
          const fakeTarget = {
            position: new THREE.Vector3(
              playerContainer.position.x + 500,
              playerContainer.position.y + Math.random() * 200 - 100,
              0
            )
          };
          
          // Fire from each eye
          shootLaserAt(fakeTarget, i);
        }
      } else {
        // Find closest enemy or obstacle
        let closestTarget = null;
        let closestDistance = Infinity;
        
        // Check enemies
        enemies.forEach(e => {
          if (e.position.x > playerContainer.position.x) { // Only target enemies in front
            const distance = e.position.distanceTo(playerContainer.position);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestTarget = e;
            }
          }
        });
        
        // Check obstacles if no enemy found
        if (!closestTarget) {
          obstacles.forEach(o => {
            if (o.position.x > playerContainer.position.x) { // Only target obstacles in front
              const distance = o.position.distanceTo(playerContainer.position);
              if (distance < closestDistance) {
                closestDistance = distance;
                closestTarget = o;
              }
            }
          });
        }
        
        // If we found a target, fire all three lasers at it
        if (closestTarget) {
          for (let i = 0; i < 3; i++) {
            shootLaserAt(closestTarget, i);
          }
          
          // Destroy the target
          if (enemies.includes(closestTarget)) {
            const index = enemies.indexOf(closestTarget);
            scene.remove(closestTarget);
            enemies.splice(index, 1);
            score += 20;
          } else if (obstacles.includes(closestTarget)) {
            const index = obstacles.indexOf(closestTarget);
            scene.remove(closestTarget);
            obstacles.splice(index, 1);
            score += 20;
          }
        }
      }
    }

    // Explosion system using particles
    function createExplosionParticle() {
      const geometry = new THREE.SphereGeometry(1, 8, 8);
      const material = new THREE.MeshBasicMaterial({
        color: 0xff5500,
        transparent: true,
        opacity: 1
      });
      
      const particle = new THREE.Mesh(geometry, material);
      particle.visible = false;
      particle.userData = {
        active: false,
        velocity: new THREE.Vector3(),
        lifetime: 0,
        scale: 1
      };
      
      scene.add(particle);
      return particle;
    }
    
    // Initialize the explosion pool
    function initExplosions() {
      for (let i = 0; i < maxExplosions; i++) {
        for (let j = 0; j < 20; j++) { // 20 particles per explosion
          explosionPool.push(createExplosionParticle());
        }
      }
    }
    
    // Trigger explosion at specific position
    function createExplosion(position, color = 0xff3300) {
      // Find 20 inactive particles for this explosion
      const particles = explosionPool.filter(p => !p.userData.active).slice(0, 20);
      if (particles.length < 20) return; // Not enough particles available
      
      // Define fire colors: red, orange, yellow
      const fireColors = [
        0xff0000, // Red
        0xff4500, // Orange-red
        0xff8300, // Orange
        0xffcc00, // Orange-yellow
        0xffff00  // Yellow
      ];
      
      // Activate all particles in this group
      particles.forEach((particle, index) => {
        // Position at explosion center
        particle.position.copy(position);
        
        // Random direction and speed
        const speed = Math.random() * 5 + 3;
        const angle = Math.random() * Math.PI * 2;
        const elevation = Math.random() * Math.PI - Math.PI/2;
        
        // Calculate 3D direction
        particle.userData.velocity.set(
          speed * Math.cos(angle) * Math.cos(elevation),
          speed * Math.sin(elevation),
          speed * Math.sin(angle) * Math.cos(elevation)
        );
        
        // Random size
        const scale = Math.random() * 5 + 3;
        particle.scale.set(scale, scale, scale);
        particle.userData.scale = scale;
        
        // Random lifetime
        particle.userData.lifetime = Math.random() * 30 + 15; // 15-45 frames (0.25-0.75 seconds)
        
        // Set one of the fire colors randomly
        const selectedColor = fireColors[Math.floor(Math.random() * fireColors.length)];
        if (particle.material.color) {
          // Convert hex color to RGB components
          const r = (selectedColor >> 16 & 255) / 255;
          const g = (selectedColor >> 8 & 255) / 255;
          const b = (selectedColor & 255) / 255;
          
          // Apply slight random variation to make each particle unique
          particle.material.color.setRGB(
            r * (0.9 + Math.random() * 0.2),
            g * (0.9 + Math.random() * 0.2),
            b * (0.9 + Math.random() * 0.2)
          );
        }
        
        // Activate
        particle.visible = true;
        particle.userData.active = true;
      });
    }
    
    // Update all active explosion particles
    function updateExplosions() {
      explosionPool.forEach(particle => {
        if (particle.userData.active) {
          // Update position based on velocity
          particle.position.add(particle.userData.velocity);
          
          // Slow down (air resistance)
          particle.userData.velocity.multiplyScalar(0.95);
          
          // Reduce lifetime
          particle.userData.lifetime--;
          
          // Shrink particle as lifetime decreases
          const lifeRatio = particle.userData.lifetime / 30;
          const currentScale = particle.userData.scale * lifeRatio;
          particle.scale.set(currentScale, currentScale, currentScale);
          
          // Update opacity based on lifetime
          particle.material.opacity = lifeRatio;
          
          // Deactivate if lifetime is over
          if (particle.userData.lifetime <= 0) {
            particle.visible = false;
            particle.userData.active = false;
          }
        }
      });
    }

    // Create and load all background images
    function setupBackgrounds() {
      // Create a fallback texture
      const fallbackTexture = createFallbackTexture('skyblue');
      
      // Calculate proper background dimensions first
      calculateBackgroundDimensions();
      
      // First, create the initial background positioned at the center of the screen
      const firstBgMaterial = new THREE.SpriteMaterial({
        map: fallbackTexture,
        transparent: true
      });
      
      const firstBg = new THREE.Sprite(firstBgMaterial);
      firstBg.scale.set(backgroundWidth, backgroundHeight, 1);
      firstBg.position.set(0, 0, -1); // Centered on screen
      firstBg.userData = { 
        fileIndex: 0,
        fileName: backgroundFiles[0]
      }; // Store the index and name of the background file
      scene.add(firstBg);
      backgrounds.push(firstBg);
      
      // Load texture for first background with better error handling
      textureLoader.load(
        backgroundFiles[0],
        (texture) => {
          console.log(`✅ Successfully loaded background: ${backgroundFiles[0]}`);
          firstBg.material.map = texture;
          firstBg.material.needsUpdate = true;
        },
        undefined,
        (err) => {
          console.error(`❌ Error loading background: ${backgroundFiles[0]}`, err);
          // Keep using fallback texture
        }
      );
      
      // Create the rest of the backgrounds, positioned to the right of each other
      for (let i = 1; i < backgroundFiles.length; i++) {
        const material = new THREE.SpriteMaterial({
          map: fallbackTexture,
          transparent: true
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(backgroundWidth, backgroundHeight, 1);
        sprite.position.set(i * backgroundWidth, 0, -1); // Position to the right
        sprite.userData = { 
          fileIndex: i,
          fileName: backgroundFiles[i]
        }; // Store the index and name of the background file
        scene.add(sprite);
        backgrounds.push(sprite);
        
        // Load the actual texture with better error handling
        textureLoader.load(
          backgroundFiles[i],
          (texture) => {
            console.log(`✅ Successfully loaded background: ${backgroundFiles[i]}`);
            sprite.material.map = texture;
            sprite.material.needsUpdate = true;
          },
          undefined,
          (err) => {
            console.error(`❌ Error loading background: ${backgroundFiles[i]}`, err);
            // Keep using fallback texture (blue)
            console.log(`Using fallback color for ${backgroundFiles[i]}`);
          }
        );
      }
      
      // Initial check of which background is visible
      setTimeout(checkBackgroundVisibility, 500);
      
      // Reset foreground bush trigger on setup
      foregroundBushTriggered = false;
    }
    
    // Set up Crypto Winter backgrounds
    function setupCryptoWinterBackgrounds() {
      console.log("Setting up Crypto Winter backgrounds...");
      
      // Remove all existing backgrounds from scene
      backgrounds.forEach(bg => scene.remove(bg));
      backgrounds.length = 0;
      
      // Also remove any existing crypto winter backgrounds
      cryptoWinterBackgrounds.forEach(bg => scene.remove(bg));
      cryptoWinterBackgrounds.length = 0;
      
      // Create a fallback texture (icy blue)
      const fallbackTexture = createFallbackTexture('lightblue');
      
      // Calculate proper background dimensions
      calculateBackgroundDimensions();
      
      // Create backgrounds for Crypto Winter
      for (let i = 0; i < cryptoWinterBackgroundFiles.length; i++) {
        const material = new THREE.SpriteMaterial({
          map: fallbackTexture,
          transparent: true
        });
        
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(backgroundWidth, backgroundHeight, 1);
        sprite.position.set(i * backgroundWidth, 0, -1);
        sprite.userData = { 
          fileIndex: i,
          fileName: cryptoWinterBackgroundFiles[i],
          isCryptoWinter: true
        };
        scene.add(sprite);
        cryptoWinterBackgrounds.push(sprite);
        
        // Load the actual texture
        textureLoader.load(
          cryptoWinterBackgroundFiles[i],
          (texture) => {
            console.log(`✅ Loaded Crypto Winter background: ${cryptoWinterBackgroundFiles[i]}`);
            sprite.material.map = texture;
            sprite.material.needsUpdate = true;
          },
          undefined,
          (err) => {
            console.error(`❌ Error loading Crypto Winter background: ${cryptoWinterBackgroundFiles[i]}`, err);
          }
        );
      }
      
      console.log(`Created ${cryptoWinterBackgrounds.length} Crypto Winter backgrounds`);
    }
    
    // Update Crypto Winter backgrounds (scrolling)
    function updateCryptoWinterBackgrounds(speed) {
      if (cryptoWinterBackgrounds.length === 0) return;
      
      // Don't scroll if ending sequence started
      if (cryptoWinterEnding) return;
      
      for (let i = 0; i < cryptoWinterBackgrounds.length; i++) {
        cryptoWinterBackgrounds[i].position.x -= speed;
        
        // If a background goes off-screen to the left, move it to the right
        if (cryptoWinterBackgrounds[i].position.x < -backgroundWidth) {
          let rightmostX = -Infinity;
          for (let j = 0; j < cryptoWinterBackgrounds.length; j++) {
            if (cryptoWinterBackgrounds[j].position.x > rightmostX) {
              rightmostX = cryptoWinterBackgrounds[j].position.x;
            }
          }
          cryptoWinterBackgrounds[i].position.x = rightmostX + backgroundWidth;
        }
      }
      
      // Determine which background is currently visible (center of screen)
      const playerX = 0; // Player is centered
      for (let i = 0; i < cryptoWinterBackgrounds.length; i++) {
        const bg = cryptoWinterBackgrounds[i];
        const bgLeft = bg.position.x - backgroundWidth / 2;
        const bgRight = bg.position.x + backgroundWidth / 2;
        
        if (playerX >= bgLeft && playerX < bgRight) {
          const newBgIndex = bg.userData.fileIndex;
          
          // Check if we entered a new background
          if (newBgIndex !== cryptoWinterCurrentBgIndex) {
            console.log(`Entered Crypto Winter background ${newBgIndex + 1}`);
            cryptoWinterCurrentBgIndex = newBgIndex;
            
            // Background 5 (index 4) - start green candle sequence
            if (newBgIndex === 4 && !greenCandleSprite) {
              console.log("Starting green candle sequence!");
              startGreenCandleSequence();
            }
            
            // Background 6 (index 5) - stop scrolling for finale
            if (newBgIndex === 5 && !cryptoWinterEnding) {
              console.log("Stopping scroll for finale!");
              cryptoWinterEnding = true; // Stop background scrolling
            }
          }
          break;
        }
      }
      
      // Determine which background is currently visible and set snow intensity
      updateCryptoWinterSnowIntensity();
    }
    
    // Start the green candle sequence - synced with audio
    function startGreenCandleSequence() {
      console.log("=== STARTING GREEN CANDLE SEQUENCE ===");
      
      // STOP snow completely when green candle appears
      currentSnowIntensity = 0;
      windStrength = 0;
      snowParticles.forEach(p => scene.remove(p));
      snowParticles.length = 0;
      if (whiteoutOverlay) {
        whiteoutOverlay.style.opacity = '0';
      }
      
      // Fade out wind audio
      if (cryptoWinterWindAudio) {
        const fadeOutWind = setInterval(() => {
          if (cryptoWinterWindAudio && cryptoWinterWindAudio.volume > 0.1) {
            cryptoWinterWindAudio.volume -= 0.1;
          } else {
            if (cryptoWinterWindAudio) {
              cryptoWinterWindAudio.pause();
              cryptoWinterWindAudio = null;
            }
            clearInterval(fadeOutWind);
          }
        }, 200);
      }
      
      // Create the green candle sprite FIRST (don't wait for audio)
      createGreenCandleSprite();
      
      // Create the sunlight exit at top of screen
      createSunlightExit();
      
      // Animate the candle rising
      animateGreenCandleRise();
      
      // Start green candle audio (play once) - but don't block on it
      greenCandleAudio = new Audio('Assets/Audio/green_candle.mp3');
      greenCandleAudio.volume = 0.8;
      greenCandleAudio.loop = false;
      
      // Only play if music is enabled
      if (musicEnabled) {
        greenCandleAudio.play().then(() => {
          console.log("Green candle audio playing (once)");
        }).catch(e => {
          console.log("Green candle audio error (continuing anyway):", e);
          // Audio failed but we continue - the visual sequence still works
        });
      }
    }
    
    // Create bright sunlight EXIT at top of screen - player can fly into this to exit Crypto Winter
    function createSunlightExit() {
      if (sunlightOverlay) return; // Already exists
      
      sunlightOverlay = document.createElement('div');
      sunlightOverlay.id = 'sunlight-overlay';
      sunlightOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 40%;
        background: linear-gradient(180deg, 
          rgba(255, 255, 220, 1) 0%, 
          rgba(255, 255, 180, 0.95) 15%,
          rgba(255, 255, 150, 0.8) 30%,
          rgba(255, 255, 100, 0.5) 50%,
          rgba(255, 255, 50, 0.2) 70%,
          transparent 100%);
        pointer-events: none;
        z-index: 60;
        opacity: 0;
        transition: opacity 3s ease;
        animation: sunlightPulse 2s ease-in-out infinite alternate;
      `;
      document.body.appendChild(sunlightOverlay);
      
      // Add pulsing animation style
      const style = document.createElement('style');
      style.textContent = `
        @keyframes sunlightPulse {
          0% { filter: brightness(1); }
          100% { filter: brightness(1.3); }
        }
      `;
      document.head.appendChild(style);
      
      // Fade in the sunlight
      setTimeout(() => {
        sunlightOverlay.style.opacity = '1';
      }, 100);
      
      console.log("Sunlight EXIT created at top of screen");
    }
    
    // Legacy function for compatibility
    function createSunlightEffect() {
      createSunlightExit();
    }
    
    // Create green candle sprite
    function createGreenCandleSprite() {
      if (!textureCache.greenCandle || greenCandleSprite) {
        console.log("Green candle texture not loaded or sprite already exists");
        return;
      }
      
      const material = new THREE.SpriteMaterial({
        map: textureCache.greenCandle,
        transparent: true
      });
      
      greenCandleSprite = new THREE.Sprite(material);
      
      // Size the green candle (tall candle)
      const candleWidth = 200;
      const candleHeight = 400;
      greenCandleSprite.scale.set(candleWidth, candleHeight, 1);
      
      // Start position: RIGHT side of screen (to avoid overlapping with pizza character)
      const xPosition = window.innerWidth / 4; // Position to the right of center
      greenCandleSprite.position.set(xPosition, -window.innerHeight / 2 - candleHeight / 2, 0.5);
      
      scene.add(greenCandleSprite);
      
      console.log("Green candle sprite created");
    }
    
    // Animate green candle rising slowly
    function animateGreenCandleRise() {
      if (!greenCandleSprite) {
        console.log("No green candle sprite to animate!");
        return;
      }
      
      console.log("Starting green candle rise animation");
      
      const screenHeight = window.innerHeight;
      const candleHeight = greenCandleSprite.scale.y;
      const sunlightY = screenHeight / 2 - 100; // Where sunlight starts
      const exitY = screenHeight / 2 + candleHeight; // Above screen
      
      greenCandleReachedSunlight = false; // Reset flag
      console.log("Candle targets - sunlightY:", sunlightY, "exitY:", exitY);
      
      let frameCount = 0;
      function updateCandlePosition() {
        if (!greenCandleSprite) {
          console.log("Green candle sprite disappeared during animation");
          return;
        }
        
        // Rise slowly
        greenCandleSprite.position.y += 1.5; // Increased speed for faster rise
        frameCount++;
        
        // Log position every 60 frames (about 1 second)
        if (frameCount % 60 === 0) {
          console.log("Candle position:", greenCandleSprite.position.y, "greenCandleReachedSunlight:", greenCandleReachedSunlight);
        }
        
        // Check if candle has reached the sunlight
        if (!greenCandleReachedSunlight && greenCandleSprite.position.y > sunlightY) {
          greenCandleReachedSunlight = true;
          console.log("GREEN CANDLE REACHED SUNLIGHT! Exit is now open!");
        }
        
        // If candle exits screen, keep it there (don't reset)
        if (greenCandleSprite.position.y > exitY) {
          greenCandleSprite.position.y = exitY;
        }
        
        // Continue animation while in crypto winter (don't depend on audio)
        if (inCryptoWinter && !exitingCryptoWinter) {
          requestAnimationFrame(updateCandlePosition);
        } else {
          console.log("Candle animation stopping - inCryptoWinter:", inCryptoWinter, "exitingCryptoWinter:", exitingCryptoWinter);
        }
      }
      
      // Start the animation loop
      updateCandlePosition();
    }
    
    // Check if player flies into sunlight to exit Crypto Winter
    function checkSunlightExit() {
      // Don't depend on greenCandleAudio - check for the sprite instead
      if (!inCryptoWinter || !greenCandleSprite || exitingCryptoWinter) return false;
      
      const exitThreshold = window.innerHeight / 2 - 50; // Very top of screen
      
      // Player can only exit AFTER the green candle has reached the sunlight
      if (!greenCandleReachedSunlight) {
        // Block player from going above a certain point until candle reaches sunlight
        if (playerContainer.position.y > exitThreshold - 100) {
          playerContainer.position.y = exitThreshold - 100; // Cap player position
        }
        return false;
      }
      
      // Green candle has reached sunlight - now player can exit
      if (playerContainer.position.y > exitThreshold) {
        console.log("Player flew into the sunlight! Exiting Crypto Winter!");
        exitingCryptoWinter = true;
        exitCryptoWinter();
        return true;
      }
      return false;
    }
    
    // Exit Crypto Winter and show bonus complete screen
    function exitCryptoWinter() {
      console.log("=== EXITING CRYPTO WINTER ===");
      
      try {
        // IMMEDIATELY freeze player in place
        playerVelocity = 0;
        playerContainer.position.y = 0;
        
        // Stop the game animation - CRITICAL
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
          console.log("Animation frame cancelled:", animationFrameId);
        }
        
        // Double-check animation is stopped
        gameActive = false; // Temporarily disable game
        console.log("Game temporarily disabled for bonus screen");
        
        // Stop green candle audio
        if (greenCandleAudio) {
          greenCandleAudio.pause();
          greenCandleAudio = null;
          console.log("Green candle audio stopped");
        }
        
        // Remove green candle sprite
        if (greenCandleSprite) {
          scene.remove(greenCandleSprite);
          greenCandleSprite = null;
          console.log("Green candle sprite removed");
        }
        
        // Remove sunlight overlay
        if (sunlightOverlay) {
          sunlightOverlay.remove();
          sunlightOverlay = null;
          console.log("Sunlight overlay removed");
        }
        
        // Show bonus complete screen
        console.log("About to show bonus screen...");
        showBonusCompleteScreen();
        console.log("Bonus screen function completed");
      } catch (error) {
        console.error("Error in exitCryptoWinter:", error);
        // Try to recover
        finishExitCryptoWinter();
      }
    }
    
    // Show the bonus level complete screen with score tripling
    let bonusScreenActive = false;
    let bonusContinueHandler = null;
    
    function showBonusCompleteScreen() {
      console.log("=== SHOWING BONUS SCREEN ===");
      bonusScreenActive = true;
      
      // Store original score and round it
      const originalScore = Math.round(score);
      const tripledScore = Math.round(originalScore * 3);
      
      // Triple the score (rounded)
      score = tripledScore;
      // Update score display directly (no updateScoreDisplay function exists)
      const scoreEl = document.getElementById('score');
      if (scoreEl) scoreEl.textContent = `Score: ${Math.floor(score)}`;
      console.log(`Score tripled: ${originalScore} -> ${score}`);
      
      // Create bonus screen
      const bonusScreen = document.createElement('div');
      bonusScreen.id = 'bonus-complete-screen';
      bonusScreen.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: black; z-index: 999999; display: flex; flex-direction: column; justify-content: center; align-items: center;';
      
      bonusScreen.innerHTML = `
        <div style="color: #00ff00; font-size: 64px; font-weight: bold; text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; margin-bottom: 30px; text-align: center;">
          BONUS LEVEL COMPLETE!
        </div>
        <div style="color: #ffff00; font-size: 48px; font-weight: bold; text-shadow: 0 0 15px #ffff00, 0 0 30px #ffff00; text-align: center; margin-bottom: 40px;">
          Score: ${originalScore} × 3 = ${tripledScore}!
        </div>
        <div id="bonus-countdown" style="color: #ffffff; font-size: 24px; text-align: center; margin-top: 40px;">
          Continuing in 3...
        </div>
      `;
      
      document.body.appendChild(bonusScreen);
      console.log("Bonus screen added to DOM");
      
      // Simple countdown - no click handlers needed
      const countdownEl = document.getElementById('bonus-countdown');
      
      setTimeout(() => {
        if (countdownEl) countdownEl.textContent = 'Continuing in 2...';
      }, 1000);
      
      setTimeout(() => {
        if (countdownEl) countdownEl.textContent = 'Continuing in 1...';
      }, 2000);
      
      // Auto-continue after 3 seconds - no user interaction needed
      setTimeout(() => {
        console.log("Auto-continuing from bonus screen");
        closeBonusScreen();
      }, 3000);
      
      // Backup timeout in case something goes wrong - force recovery after 10 seconds
      setTimeout(() => {
        if (bonusScreenActive) {
          console.warn("Bonus screen still active after 10 seconds - forcing recovery");
          forceRecoverFromCryptoWinter();
        }
      }, 10000);
    }
    
    function closeBonusScreen() {
      if (!bonusScreenActive) {
        console.log("Bonus screen not active, skipping close");
        return;
      }
      bonusScreenActive = false;
      
      console.log("=== CLOSING BONUS SCREEN ===");
      
      try {
        // Remove the screen
        const screen = document.getElementById('bonus-complete-screen');
        if (screen) {
          screen.remove();
          console.log("Bonus screen removed from DOM");
        }
        
        // Continue to finish exit
        console.log("Calling finishExitCryptoWinter...");
        finishExitCryptoWinter();
      } catch (error) {
        console.error("Error in closeBonusScreen:", error);
        // Force recovery
        forceRecoverFromCryptoWinter();
      }
    }
    
    // Emergency recovery function if something goes wrong
    function forceRecoverFromCryptoWinter() {
      console.warn("=== FORCE RECOVERING FROM CRYPTO WINTER ===");
      
      // Reset all state flags
      inCryptoWinter = false;
      cryptoWinterEnding = false;
      cryptoWinterCurrentBgIndex = 0;
      exitingCryptoWinter = false;
      greenCandleReachedSunlight = false;
      bonusScreenActive = false;
      gameActive = true;
      gameOver = false;
      
      // Remove any bonus screen
      const bonusScreen = document.getElementById('bonus-complete-screen');
      if (bonusScreen) bonusScreen.remove();
      
      // Clean up any remaining Crypto Winter elements
      cryptoWinterBackgrounds.forEach(bg => scene.remove(bg));
      cryptoWinterBackgrounds.length = 0;
      snowParticles.forEach(p => scene.remove(p));
      snowParticles.length = 0;
      if (greenCandleSprite) { scene.remove(greenCandleSprite); greenCandleSprite = null; }
      if (sunlightOverlay) { sunlightOverlay.remove(); sunlightOverlay = null; }
      if (whiteoutOverlay) { whiteoutOverlay.style.opacity = '0'; }
      
      // Reset player
      playerVelocity = 0;
      playerContainer.position.y = 0;
      playerContainer.position.x = 0;
      const playerSizeObj = getPlayerSize();
      player.scale.set(playerSizeObj.width, playerSizeObj.height, 1);
      player.width = playerSizeObj.width;
      player.height = playerSizeObj.height;
      updatePlayerTexture();
      
      // Setup backgrounds at Oslo
      setupBackgrounds();
      const osloOffset = 8 * backgroundWidth;
      backgrounds.forEach((bg, index) => {
        bg.position.x = (index * backgroundWidth) - osloOffset;
      });
      currentBackgroundIndex = 8;
      
      // Restart game
      playBackgroundMusic('gameMusic1');
      gameStartTime = 0; // Reset for grace period
      lastFrameTime = 0; // Reset delta time
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animationFrameId = requestAnimationFrame(animate);
      
      console.log("=== FORCE RECOVERY COMPLETE ===");
    }
    
    // Finish exiting Crypto Winter and return to normal game
    function finishExitCryptoWinter() {
      console.log("=== FINISHING CRYPTO WINTER EXIT ===");
      
      try {
        // Reset Crypto Winter state FIRST
        inCryptoWinter = false;
        cryptoWinterEnding = false;
        cryptoWinterCurrentBgIndex = 0;
        exitingCryptoWinter = false;
        greenCandleReachedSunlight = false;
        bonusScreenActive = false;
        
        console.log("State reset complete");
        
        // Clean up Crypto Winter backgrounds
        cryptoWinterBackgrounds.forEach(bg => scene.remove(bg));
        cryptoWinterBackgrounds.length = 0;
        console.log("Crypto winter backgrounds removed");
        
        // Clear any remaining snow
        snowParticles.forEach(p => scene.remove(p));
        snowParticles.length = 0;
        
        // Remove whiteout overlay
        if (whiteoutOverlay) {
          whiteoutOverlay.style.opacity = '0';
        }
        
        // Remove foreground trees
        removeForegroundTree();
        
        // Reset player to normal size and texture
        const playerSizeObj = getPlayerSize();
        player.scale.set(playerSizeObj.width, playerSizeObj.height, 1);
        player.width = playerSizeObj.width;
        player.height = playerSizeObj.height;
        updatePlayerTexture();
        console.log("Player reset complete");
        
        // Position player safely in middle of screen with ZERO velocity
        playerContainer.position.y = 0;
        playerContainer.position.x = 0;
        playerVelocity = 0; // CRITICAL: Reset velocity so player doesn't fall immediately
        
        // Make sure game is active
        gameActive = true;
        gameOver = false;
        
        // Reset game start time to give grace period
        gameStartTime = 0;
        
        // Restore regular backgrounds and set to Oslo (index 8)
        setupBackgrounds();
        
        // Position backgrounds so Oslo is visible (player returns to Oslo)
        // Oslo is at index 8, so we need to scroll backgrounds left by 8 * backgroundWidth
        const osloOffset = 8 * backgroundWidth;
        backgrounds.forEach((bg, index) => {
          bg.position.x = (index * backgroundWidth) - osloOffset;
        });
        currentBackgroundIndex = 8;
        
        console.log("Backgrounds restored, player at Oslo");
        
        // Resume normal background music
        playBackgroundMusic('gameMusic1');
        
        // Resume game animation - CRITICAL
        console.log("About to restart animation loop...");
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(animate);
        
        console.log("=== RETURNED TO NORMAL GAME ===");
      } catch (error) {
        console.error("ERROR in finishExitCryptoWinter:", error);
        // Use force recovery for consistency
        forceRecoverFromCryptoWinter();
      }
    }
    
    // Create a single snow particle
    function createSnowParticle() {
      const canvas = document.createElement('canvas');
      canvas.width = 16;
      canvas.height = 16;
      const ctx = canvas.getContext('2d');
      
      // Draw a soft white circle
      const gradient = ctx.createRadialGradient(8, 8, 0, 8, 8, 8);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 16, 16);
      
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false
      });
      
      const particle = new THREE.Sprite(material);
      
      // Size increases with intensity (bigger flakes in blizzard)
      const baseSize = 4 + currentSnowIntensity * 2;
      const size = baseSize + Math.random() * (baseSize * 0.8);
      particle.scale.set(size, size, 1);
      
      // Start position - random across screen width, above screen
      particle.position.set(
        (Math.random() - 0.5) * window.innerWidth * 1.5,
        window.innerHeight / 2 + Math.random() * 100,
        0.5 // In front of backgrounds
      );
      
      // Store velocity data - faster falling at higher intensities
      const fallSpeed = 2 + Math.random() * 3 + currentSnowIntensity * 1.5;
      particle.userData = {
        velocityX: 0,
        velocityY: -fallSpeed, // Falling speed increases with intensity
        wobble: Math.random() * Math.PI * 2, // For sideways wobble
        wobbleSpeed: 0.02 + Math.random() * 0.03 + currentSnowIntensity * 0.01
      };
      
      scene.add(particle);
      snowParticles.push(particle);
      
      return particle;
    }
    
    // Whiteout overlay element
    let whiteoutOverlay = null;
    
    // Update snow intensity based on time spent in Crypto Winter
    function updateCryptoWinterSnowIntensity() {
      if (!inCryptoWinter) return;
      
      // Calculate time since entering Crypto Winter
      const timeInLevel = Date.now() - cryptoWinterStartTime;
      
      // Increase intensity every 8 seconds, max at level 4
      const newIntensity = Math.min(4, Math.floor(timeInLevel / snowIntensityInterval));
      
      // Only log when intensity changes
      if (newIntensity !== currentSnowIntensity) {
        console.log(`Snow intensity increased to level ${newIntensity}`);
      }
      
      currentSnowIntensity = newIntensity;
      
      // Set wind strength - gets stronger with each level
      // Level 0: light wind, Level 4: extreme blizzard wind
      windStrength = 0.1 + currentSnowIntensity * 0.3;
      
      // Create/update whiteout overlay for high intensity levels
      updateWhiteoutOverlay();
    }
    
    // Create and update whiteout overlay effect
    function updateWhiteoutOverlay() {
      // Create overlay if it doesn't exist
      if (!whiteoutOverlay) {
        whiteoutOverlay = document.createElement('div');
        whiteoutOverlay.id = 'whiteout-overlay';
        whiteoutOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: white;
          pointer-events: none;
          z-index: 50;
          opacity: 0;
          transition: opacity 0.5s ease;
        `;
        document.body.appendChild(whiteoutOverlay);
      }
      
      // Set opacity based on intensity (starts at level 2, max at level 4)
      let whiteoutOpacity = 0;
      if (currentSnowIntensity >= 2) {
        // Level 2: 0.1, Level 3: 0.25, Level 4: 0.45 (heavy whiteout)
        whiteoutOpacity = (currentSnowIntensity - 1) * 0.15;
      }
      
      whiteoutOverlay.style.opacity = whiteoutOpacity;
    }
    
    // Remove whiteout overlay
    function removeWhiteoutOverlay() {
      if (whiteoutOverlay) {
        whiteoutOverlay.remove();
        whiteoutOverlay = null;
      }
    }
    
    // Update all snow particles
    function updateSnowParticles() {
      if (!inCryptoWinter) return;
      
      // Spawn rate based on intensity (more particles for higher intensity)
      // Level 0: 50 particles (light), Level 1: 150, Level 2: 300, Level 3: 500, Level 4: 800 (whiteout)
      const targetParticles = 50 + currentSnowIntensity * 180;
      const spawnRate = 3 + currentSnowIntensity * 4; // Spawn 3-19 particles per frame
      
      // Spawn new particles if needed
      if (snowParticles.length < targetParticles && snowParticles.length < maxSnowParticles) {
        for (let i = 0; i < spawnRate; i++) {
          if (snowParticles.length < maxSnowParticles) {
            createSnowParticle();
          }
        }
      }
      
      // Update existing particles
      for (let i = snowParticles.length - 1; i >= 0; i--) {
        const p = snowParticles[i];
        
        // Wind effect increases dramatically with intensity
        const windEffect = (Math.sin(Date.now() * 0.001 + p.userData.wobble) * 0.5 + 0.5) * windStrength * 5;
        const gustEffect = currentSnowIntensity >= 3 ? Math.sin(Date.now() * 0.003) * (currentSnowIntensity - 1) : 0;
        
        // Update wobble
        p.userData.wobble += p.userData.wobbleSpeed;
        
        // Apply movement
        p.position.x += p.userData.velocityX + windEffect + gustEffect + Math.sin(p.userData.wobble) * (0.5 + currentSnowIntensity * 0.3);
        p.position.y += p.userData.velocityY;
        
        // For medium-heavy snow (level 3+), make particles move more chaotically
        if (currentSnowIntensity >= 3) {
          p.position.x += (Math.random() - 0.3) * (currentSnowIntensity * 1.5); // Increasing chaos
          p.position.y += (Math.random() - 0.5) * currentSnowIntensity * 0.5;
        }
        
        // For whiteout (level 4), extreme chaos
        if (currentSnowIntensity >= 4) {
          p.position.x += (Math.random() - 0.2) * 5; // Strong rightward bias
          p.position.y += (Math.random() - 0.5) * 3; // Vertical chaos
        }
        
        // Remove particles that are off screen
        if (p.position.y < -window.innerHeight / 2 - 50 || 
            p.position.x > window.innerWidth / 2 + 100 ||
            p.position.x < -window.innerWidth / 2 - 100) {
          scene.remove(p);
          snowParticles.splice(i, 1);
        }
      }
    }
    
    // Apply wind effect to player in Crypto Winter - shaky gusts, no drift
    let windShakeOffset = { x: 0, y: 0 }; // Track shake offset separately
    let lastGustTime = 0;
    let currentGust = { x: 0, y: 0 };
    let gustDuration = 0;
    
    function applyWindToPlayer() {
      if (!inCryptoWinter || !gameActive || gameOver) return;
      
      const now = Date.now();
      const playerXPosition = getPlayerXPosition(); // Get the intended center position
      
      // Shake intensity increases with snow intensity (0-4)
      // Level 1: very subtle shake
      // Level 2: noticeable shake
      // Level 3: strong shake with gusts
      // Level 4: violent shaking with big gusts
      const shakeMultiplier = [0, 0.5, 1.5, 3, 6][currentSnowIntensity] || 0;
      
      // Base continuous shake - small rapid oscillations
      const shakeFreqX = 0.008 + currentSnowIntensity * 0.002;
      const shakeFreqY = 0.006 + currentSnowIntensity * 0.0015;
      const baseShakeX = Math.sin(now * shakeFreqX) * shakeMultiplier * 2;
      const baseShakeY = Math.sin(now * shakeFreqY + 1000) * shakeMultiplier * 1.5;
      
      // Random gusts - sudden pushes that decay
      if (currentSnowIntensity >= 2 && now - lastGustTime > gustDuration + 500) {
        // Start a new gust
        const gustChance = currentSnowIntensity >= 4 ? 0.03 : (currentSnowIntensity >= 3 ? 0.015 : 0.008);
        if (Math.random() < gustChance) {
          lastGustTime = now;
          gustDuration = 200 + Math.random() * 400; // Gust lasts 200-600ms
          // Gust direction is random but biased slightly left (into the wind)
          currentGust.x = (Math.random() - 0.6) * shakeMultiplier * 8;
          currentGust.y = (Math.random() - 0.5) * shakeMultiplier * 4;
        }
      }
      
      // Decay the gust over time
      let gustX = 0, gustY = 0;
      if (now - lastGustTime < gustDuration) {
        const gustProgress = (now - lastGustTime) / gustDuration;
        const gustDecay = 1 - gustProgress; // Linear decay
        gustX = currentGust.x * gustDecay;
        gustY = currentGust.y * gustDecay;
      }
      
      // Micro-turbulence at high intensity - rapid random jitter
      let turbulenceX = 0, turbulenceY = 0;
      if (currentSnowIntensity >= 3) {
        turbulenceX = (Math.random() - 0.5) * shakeMultiplier * 1.5;
        turbulenceY = (Math.random() - 0.5) * shakeMultiplier * 1;
      }
      
      // Calculate total shake offset (this oscillates around zero, no drift)
      windShakeOffset.x = baseShakeX + gustX + turbulenceX;
      windShakeOffset.y = baseShakeY + gustY + turbulenceY;
      
      // Gently pull player back toward center X position to prevent drift
      const centeringForce = (playerXPosition - playerContainer.position.x) * 0.02;
      
      // Apply shake as an offset from current position, plus centering
      playerContainer.position.x += windShakeOffset.x * 0.3 + centeringForce;
      playerContainer.position.y += windShakeOffset.y * 0.2;
      
      // Keep player within bounds
      const maxX = window.innerWidth / 2 - 100;
      const minX = -window.innerWidth / 2 + 100;
      playerContainer.position.x = Math.max(minX, Math.min(maxX, playerContainer.position.x));
    }
    
    // Clear all snow particles
    function clearSnowParticles() {
      for (let i = snowParticles.length - 1; i >= 0; i--) {
        scene.remove(snowParticles[i]);
      }
      snowParticles.length = 0;
      currentSnowIntensity = 0;
      windStrength = 0;
      // Remove whiteout overlay
      removeWhiteoutOverlay();
      // Remove foreground tree
      removeForegroundTree();
    }
    
    // Create foreground tree sprites
    function createForegroundTree() {
      if (foregroundTree) return; // Already exists
      
      // Tree 1
      const material1 = new THREE.SpriteMaterial({
        map: textureCache.snowTreeForeground,
        transparent: true,
        depthTest: false
      });
      
      foregroundTree = new THREE.Sprite(material1);
      
      // Make the tree very large (zoomed in) - about 2x screen height
      const treeHeight = window.innerHeight * 2;
      const treeWidth = treeHeight * 0.6; // Approximate aspect ratio for a tree
      foregroundTree.scale.set(treeWidth, treeHeight, 1);
      
      // Position: START off-screen to the right, will scroll in
      // z = 1 puts it in front of the player (player is around z = 0)
      foregroundTree.position.set(
        window.innerWidth / 2 + treeWidth, // Off-screen right
        -window.innerHeight / 4, // Shifted down so bottom is cut off
        1 // In front of player
      );
      
      foregroundTree.visible = false;
      scene.add(foregroundTree);
      
      // Tree 2
      const material2 = new THREE.SpriteMaterial({
        map: textureCache.snowTreeForeground,
        transparent: true,
        depthTest: false
      });
      
      foregroundTree2 = new THREE.Sprite(material2);
      
      // Slightly different size for variety
      const tree2Height = window.innerHeight * 1.8;
      const tree2Width = tree2Height * 0.6;
      foregroundTree2.scale.set(tree2Width, tree2Height, 1);
      
      // Position: START off-screen to the right, offset from first tree
      foregroundTree2.position.set(
        window.innerWidth / 2 + treeWidth + tree2Width + 200, // Off-screen right, after first tree
        -window.innerHeight / 3, // Shifted down so bottom is cut off
        1.1 // Slightly in front of first tree
      );
      
      foregroundTree2.visible = false;
      scene.add(foregroundTree2);
      
      console.log("Foreground trees created (off-screen right)");
    }
    
    // Update foreground tree visibility and position based on current background
    function updateForegroundTree() {
      if (!inCryptoWinter || !foregroundTree || !foregroundTree2) return;
      
      // Find which Crypto Winter background is currently most visible
      let currentBgIndex = -1;
      let maxVisibility = 0;
      
      for (let i = 0; i < cryptoWinterBackgrounds.length; i++) {
        const bg = cryptoWinterBackgrounds[i];
        const bgLeft = bg.position.x - backgroundWidth / 2;
        const bgRight = bg.position.x + backgroundWidth / 2;
        
        const visibleLeft = Math.max(bgLeft, -window.innerWidth / 2);
        const visibleRight = Math.min(bgRight, window.innerWidth / 2);
        const visibility = Math.max(0, visibleRight - visibleLeft);
        
        if (visibility > maxVisibility) {
          maxVisibility = visibility;
          currentBgIndex = bg.userData.fileIndex;
        }
      }
      
      // Show trees only on background 3 (index 2)
      // Trees become visible when entering background 3 (index 2) and stay visible until off-screen
      const shouldActivate = currentBgIndex >= 2;
      
      if (shouldActivate && !foregroundTreeVisible) {
        foregroundTree.visible = true;
        foregroundTree2.visible = true;
        foregroundTreeVisible = true;
        console.log("Foreground trees now visible");
      }
      
      // Move trees with the background scroll (faster than background for parallax effect)
      // Trees continue scrolling even after leaving background 3 - they scroll off the left
      if (foregroundTreeVisible) {
        const treeScrollSpeed = backgroundSpeed * 1.5; // Trees move faster (foreground parallax)
        foregroundTree.position.x -= treeScrollSpeed;
        foregroundTree2.position.x -= treeScrollSpeed;
        
        // DON'T reset trees - let them scroll off the left side of the screen permanently
        // They only appear once during background 3 and then leave
      }
    }
    
    // Remove foreground trees
    function removeForegroundTree() {
      if (foregroundTree) {
        scene.remove(foregroundTree);
        foregroundTree = null;
      }
      if (foregroundTree2) {
        scene.remove(foregroundTree2);
        foregroundTree2 = null;
      }
      foregroundTreeVisible = false;
    }
    
    // Create foreground bush for main game (hides seam between background3 and Jaipur)
    function createForegroundBush() {
      if (foregroundBush || !textureCache.bush) return;
      
      const material = new THREE.SpriteMaterial({
        map: textureCache.bush,
        transparent: true,
        depthTest: false
      });
      
      foregroundBush = new THREE.Sprite(material);
      
      // Size the bush - image is wider than tall (approximately 1.3:1 width:height ratio)
      // Make it short enough to not be too prominent
      const bushHeight = window.innerHeight * 0.25; // 25% of screen height (shorter)
      const bushWidth = bushHeight * 1.4; // Bush is wider than tall
      foregroundBush.scale.set(bushWidth, bushHeight, 1);
      
      // Position: Start off-screen right, bottom of bush touches bottom of screen
      foregroundBush.position.set(
        window.innerWidth / 2 + bushWidth, // Off-screen right
        -window.innerHeight / 2 + bushHeight / 2, // Bottom of bush at bottom of screen
        0.5 // In front of backgrounds but behind player
      );
      
      foregroundBush.visible = false;
      scene.add(foregroundBush);
      console.log("Foreground bush created (off-screen right)");
    }
    
    // Update foreground bush - appears at transition from background3 to Jaipur
    function updateForegroundBush() {
      // Safety checks - don't run if game not active
      if (inCryptoWinter || !gameActive || !backgrounds || backgrounds.length < 4) return;
      
      // Create bush on demand if it doesn't exist yet
      if (!foregroundBush && textureCache.bush) {
        createForegroundBush();
      }
      
      // If bush still doesn't exist, return
      if (!foregroundBush) return;
      
      // Find where background 3 (Jaipur) starts - this is the seam we want to cover
      const bg3 = backgrounds[3]; // Jaipur background
      if (!bg3 || !bg3.position) return;
      
      const bg3Left = bg3.position.x - backgroundWidth / 2;
      const screenRight = window.innerWidth / 2;
      const screenLeft = -window.innerWidth / 2;
      
      // Show bush when the seam is approaching or on screen
      if (bg3Left < screenRight + 300 && bg3Left > screenLeft - 300) {
        if (!foregroundBush.visible) {
          foregroundBush.visible = true;
          console.log("Foreground bush now visible, bg3Left:", bg3Left);
        }
        // Keep bush positioned at the seam (left edge of Jaipur background)
        foregroundBush.position.x = bg3Left;
      } else if (bg3Left <= screenLeft - 300) {
        // Hide once the seam has scrolled well off screen left
        if (foregroundBush.visible) {
          foregroundBush.visible = false;
          console.log("Foreground bush hidden - seam passed");
        }
      }
    }
    
    // Remove foreground bush (for cleanup)
    function removeForegroundBush() {
      if (foregroundBush) {
        scene.remove(foregroundBush);
        foregroundBush = null;
      }
      foregroundBushTriggered = false;
    }
    
    // Create foreground snowpile for Oslo level seam
    function createForegroundSnowpile() {
      if (foregroundSnowpile || !textureCache.snowpile) return;
      
      const material = new THREE.SpriteMaterial({
        map: textureCache.snowpile,
        transparent: true,
        depthTest: false
      });
      
      foregroundSnowpile = new THREE.Sprite(material);
      
      // Size the snowpile - 50% smaller than before
      // Image is very wide and flat (approximately 4:1 width:height ratio)
      const pileHeight = window.innerHeight * 0.125; // 12.5% of screen height (50% of 25%)
      const pileWidth = pileHeight * 4; // Very wide snowpile
      foregroundSnowpile.scale.set(pileWidth, pileHeight, 1);
      
      // Position: Start off-screen, raised a bit from bottom
      foregroundSnowpile.position.set(
        window.innerWidth / 2 + pileWidth, // Off-screen right
        -window.innerHeight / 2 + pileHeight / 2 + 30, // Raised 30px from bottom
        0.5 // In front of backgrounds but behind player
      );
      
      foregroundSnowpile.visible = false;
      scene.add(foregroundSnowpile);
      console.log("Foreground snowpile created");
    }
    
    // Update foreground snowpile - appears at transition to Oslo (index 8)
    function updateForegroundSnowpile() {
      // Safety checks - don't run if game not active
      if (inCryptoWinter || !gameActive || !backgrounds || backgrounds.length < 9) return;
      
      // Create snowpile on demand if it doesn't exist yet
      if (!foregroundSnowpile && textureCache.snowpile) {
        createForegroundSnowpile();
      }
      
      // If snowpile still doesn't exist, return
      if (!foregroundSnowpile) return;
      
      // Find where Oslo (index 8) starts - this is the seam we want to cover
      const bgOslo = backgrounds[8]; // Oslo background
      if (!bgOslo || !bgOslo.position) return;
      
      const osloLeft = bgOslo.position.x - backgroundWidth / 2;
      const screenRight = window.innerWidth / 2;
      const screenLeft = -window.innerWidth / 2;
      
      // Show snowpile when the seam is approaching or on screen
      if (osloLeft < screenRight + 300 && osloLeft > screenLeft - 300) {
        if (!foregroundSnowpile.visible) {
          foregroundSnowpile.visible = true;
          console.log("Foreground snowpile now visible, osloLeft:", osloLeft);
        }
        // Keep snowpile positioned at the seam (left edge of Oslo background)
        foregroundSnowpile.position.x = osloLeft;
      } else if (osloLeft <= screenLeft - 300) {
        // Hide once the seam has scrolled well off screen left
        if (foregroundSnowpile.visible) {
          foregroundSnowpile.visible = false;
          console.log("Foreground snowpile hidden - seam passed");
        }
      }
    }
    
    // Remove foreground snowpile (for cleanup)
    function removeForegroundSnowpile() {
      if (foregroundSnowpile) {
        scene.remove(foregroundSnowpile);
        foregroundSnowpile = null;
      }
      if (foregroundSnowpileRight) {
        scene.remove(foregroundSnowpileRight);
        foregroundSnowpileRight = null;
      }
    }
    
    // Create foreground snowpile for the RIGHT seam of Oslo (Oslo to Rio transition)
    function createForegroundSnowpileRight() {
      if (foregroundSnowpileRight || !textureCache.snowpile) return;
      
      const material = new THREE.SpriteMaterial({
        map: textureCache.snowpile,
        transparent: true,
        depthTest: false
      });
      
      foregroundSnowpileRight = new THREE.Sprite(material);
      
      // Same size as the left snowpile
      const pileHeight = window.innerHeight * 0.125;
      const pileWidth = pileHeight * 4;
      foregroundSnowpileRight.scale.set(pileWidth, pileHeight, 1);
      
      // Position: Start off-screen, raised a bit from bottom
      foregroundSnowpileRight.position.set(
        window.innerWidth / 2 + pileWidth,
        -window.innerHeight / 2 + pileHeight / 2 + 30, // Raised 30px from bottom
        0.5
      );
      
      foregroundSnowpileRight.visible = false;
      scene.add(foregroundSnowpileRight);
      console.log("Foreground snowpile (right) created");
    }
    
    // Update foreground snowpile for right seam - appears at transition from Oslo to Rio (index 8 to 9)
    function updateForegroundSnowpileRight() {
      // Safety checks - don't run if game not active
      if (inCryptoWinter || !gameActive || !backgrounds || backgrounds.length < 10) return;
      
      // Create snowpile on demand if it doesn't exist yet
      if (!foregroundSnowpileRight && textureCache.snowpile) {
        createForegroundSnowpileRight();
      }
      
      // If snowpile still doesn't exist, return
      if (!foregroundSnowpileRight) return;
      
      // Find where Rio (index 9) starts - this is the right seam of Oslo
      const bgRio = backgrounds[9]; // Rio background
      if (!bgRio || !bgRio.position) return;
      
      const rioLeft = bgRio.position.x - backgroundWidth / 2; // Left edge of Rio = Right edge of Oslo
      const screenRight = window.innerWidth / 2;
      const screenLeft = -window.innerWidth / 2;
      
      // Show snowpile when the seam is approaching or on screen
      if (rioLeft < screenRight + 300 && rioLeft > screenLeft - 300) {
        if (!foregroundSnowpileRight.visible) {
          foregroundSnowpileRight.visible = true;
          console.log("Foreground snowpile (right) now visible, rioLeft:", rioLeft);
        }
        // Keep snowpile positioned at the seam (left edge of Rio = right edge of Oslo)
        foregroundSnowpileRight.position.x = rioLeft;
      } else if (rioLeft <= screenLeft - 300) {
        // Hide once the seam has scrolled well off screen left
        if (foregroundSnowpileRight.visible) {
          foregroundSnowpileRight.visible = false;
          console.log("Foreground snowpile (right) hidden - seam passed");
        }
      }
    }

    // Background music elements (variables declared at top of script)

    // Function to test file existence
    function checkFileExists(url) {
      console.log(`Testing if file exists: ${url}`);
      
      return new Promise((resolve, reject) => {
        fetch(url, { method: 'HEAD' })
          .then(response => {
            if (response.ok) {
              console.log(`✅ File exists: ${url}`);
              resolve(true);
            } else {
              console.error(`❌ File not found: ${url} (${response.status})`);
              resolve(false);
            }
          })
          .catch(error => {
            console.error(`❌ Error checking file: ${url}`, error);
            resolve(false);
          });
      });
    }
    
    // Check all audio files and log results
    async function verifyAudioFiles() {
      console.log("======= VERIFYING AUDIO FILES =======");
      
      for (const [key, path] of Object.entries(soundFiles)) {
        const exists = await checkFileExists(path);
        console.log(`${key}: ${exists ? "✅ Found" : "❌ Missing"} - ${path}`);
        
        // If file is missing, try alternative paths
        if (!exists) {
          // Try without Assets prefix
          const altPath1 = path.replace('Assets/', '');
          const exists1 = await checkFileExists(altPath1);
          if (exists1) {
            console.log(`Found at alternative path: ${altPath1}`);
            soundFiles[key] = altPath1; // Update path
          }
          
          // Try with different capitalization
          const altPath2 = path.replace('Assets/Audio', 'assets/audio');
          const exists2 = await checkFileExists(altPath2);
          if (exists2) {
            console.log(`Found at alternative path: ${altPath2}`);
            soundFiles[key] = altPath2; // Update path
          }
        }
      }
      
      console.log("======= AUDIO FILE VERIFICATION COMPLETE =======");
    }
    
    // Run verification
    verifyAudioFiles();

    // Function to stop background music
    function stopBackgroundMusic() {
      console.log("Stopping all background music");
      
      // Stop the tracked current music
      if (currentMusic) {
        try {
          currentMusic.pause();
          currentMusic.currentTime = 0;
          currentMusic = null;
          console.log("Successfully stopped tracked background music");
        } catch(e) {
          console.error("Error stopping tracked music:", e);
        }
      }
      
      // Additional safety: stop any other audio elements playing music
      const allAudio = document.querySelectorAll('audio');
      allAudio.forEach(audio => {
        try {
          audio.pause();
          audio.currentTime = 0;
          console.log("Stopped additional audio element");
        } catch(e) {
          console.error("Error stopping additional audio:", e);
        }
      });
      
      // Final safety: look for any audio with our music paths
      Object.values(soundFiles).forEach(path => {
        // Check if there are any audio elements with this source
        const matchingAudios = Array.from(document.querySelectorAll('audio')).filter(
          audio => audio.src.includes(path.replace(/^Assets\//, ''))
        );
        
        matchingAudios.forEach(audio => {
          try {
            audio.pause();
            audio.currentTime = 0;
            console.log(`Stopped audio playing ${path}`);
          } catch(e) {
            console.error(`Error stopping audio with ${path}:`, e);
          }
        });
      });
    }
    
    // Global array to track all music players
    const allMusicPlayers = [];
    
    // Track which gameplay music is currently playing
    let currentGameMusicTrack = 1;
    const totalGameMusicTracks = 5; // Update this if you add/remove tracks
    
    // Function to play background music for a specific screen
    function playBackgroundMusic(musicType) {
      console.log(`============= PLAYING ${musicType} =============`);
      
      // Always stop ALL music first
      stopBackgroundMusic();
      
      if (!audioEnabled) {
        console.log("Audio not enabled, can't play music");
        return null;
      }
      
      if (!musicEnabled) {
        console.log("Music is disabled by user");
        return null;
      }
      
      // If the music type is "gameMusic", select from the available tracks
      let actualMusicType = musicType;
      if (musicType === 'gameMusic') {
        actualMusicType = `gameMusic${currentGameMusicTrack}`;
        console.log(`Selected gameplay music track ${currentGameMusicTrack} of ${totalGameMusicTracks}`);
      }
      
      const musicPath = soundFiles[actualMusicType];
      if (!musicPath) {
        console.error(`No path defined for music type: ${actualMusicType}`);
        return null;
      }
      
      try {
        console.log(`Attempting to play ${actualMusicType} from ${musicPath}`);
        
        // Create a new audio element for the music
        currentMusic = new Audio(musicPath);
        currentMusic.volume = musicVolume;
        
        // Only loop if it's not gameplay music
        currentMusic.loop = !actualMusicType.startsWith('gameMusic');
        
        // Add event listeners for debugging
        currentMusic.addEventListener('play', () => {
          console.log(`${actualMusicType} started playing`);
        });
        
        currentMusic.addEventListener('error', (e) => {
          console.error(`Error with ${actualMusicType}:`, e);
        });
        
        // For gameplay music, ALWAYS add ended event to switch to next track
        if (actualMusicType.startsWith('gameMusic')) {
          currentMusic.addEventListener('ended', () => {
            console.log(`${actualMusicType} ended, checking if should play next track...`);
            console.log(`gameActive: ${gameActive}, gameOver: ${gameOver}, inCryptoWinter: ${inCryptoWinter}, musicEnabled: ${musicEnabled}`);
            
            // Advance to the next track in sequence
            currentGameMusicTrack = (currentGameMusicTrack % totalGameMusicTracks) + 1;
            console.log(`Advancing to track: ${currentGameMusicTrack}`);
            
            // Only play the next track if the game is still active and not in ice level
            if (gameActive && !gameOver && !inCryptoWinter && musicEnabled) {
              console.log("Playing next gameplay music track...");
              playGameplayMusic();
            } else {
              console.log("Not playing next track - game state doesn't allow it");
            }
          });
        }
        
        // Try to play
        const playPromise = currentMusic.play()
          .catch(e => {
            console.error("Play failed:", e);
          });
          
        return currentMusic;
      } catch(e) {
        console.error(`Exception with ${actualMusicType}: ${e.message}`);
        return null;
      }
    }

    // Initialize the scene
    startRenderLoop();
    
    // Update the DOMContentLoaded handler to properly initialize music
    document.addEventListener('DOMContentLoaded', function() {
      console.log("Document loaded, setting up game...");
      
      // Remove any existing click handlers on the start button
      const startButton = document.getElementById('start-button');
      const newStartButton = startButton.cloneNode(true);
      startButton.parentNode.replaceChild(newStartButton, startButton);
      
      // Set up the Start button with explicit music handling
      newStartButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Track that user has interacted with the page
        audioEnabled = true;
        
        // Start the game (this will handle music too)
        startGame();
      });
      
      // Set up event listeners for game over elements
      setupGameOverEventListeners();
      
      // Try to pre-enable audio after a short delay
      setTimeout(function() {
        console.log("Attempting to initialize audio on page load");
        enableAudio();
        
        // Explicitly try to play menu music on page load
        playBackgroundMusic('menuMusic');
        
        // Add click handler to document to enable music after first interaction
        const firstInteractionHandler = function() {
          console.log("First user interaction detected");
          
          // Only play if we're on the start screen
          if (!gameActive && !gameOver) {
            playBackgroundMusic('menuMusic');
          }
          
          // Remove this handler after first use
          document.removeEventListener('click', firstInteractionHandler);
          document.removeEventListener('touchstart', firstInteractionHandler);
          document.removeEventListener('keydown', firstInteractionHandler);
        };
        
        // Add handlers for first interaction
        document.addEventListener('click', firstInteractionHandler);
        document.addEventListener('touchstart', firstInteractionHandler);
        document.addEventListener('keydown', firstInteractionHandler);
      }, 500);
    });
    
    // Setup event listeners for game over screen (with handlers to prevent duplicates)
    let gameOverListenersSetup = false;
    
    function handleRetryClick(e) {
      e.stopPropagation();
      console.log("🎮 Retry button clicked (single handler)");
      stopBackgroundMusic();
      playGameplayMusic();
      restartGame();
    }
    
    function handleMainMenuClick(e) {
      e.stopPropagation();
      stopBackgroundMusic();
      playBackgroundMusic('menuMusic');
      showStartScreen();
    }
    
    function setupGameOverEventListeners() {
      if (gameOverListenersSetup) {
        console.log("⚠️ Game over listeners already setup, skipping");
        return;
      }
      
      const gameOverElement = document.getElementById('game-over');
      if (gameOverElement) {
        gameOverElement.addEventListener('click', function(e) {
          e.stopPropagation();
        });
      }
      
      const retryButton = document.getElementById('retry-button');
      if (retryButton) {
        retryButton.addEventListener('click', handleRetryClick);
      }
      
      const mainMenuButton = document.getElementById('main-menu-button');
      if (mainMenuButton) {
        mainMenuButton.addEventListener('click', handleMainMenuClick);
      }
      
      gameOverListenersSetup = true;
      console.log("✅ Game over event listeners setup complete");
    }
    
    // Add a pre-start music function for when we click on the page anywhere
    function playStartScreenMusicIfNeeded() {
      if (!gameActive && !gameOver) {
        console.log("User interaction on start screen, ensuring music is playing");
        playBackgroundMusic('menuMusic');
      }
    }
    
    // Add click handlers to try playing music after any interaction
    document.addEventListener('click', playStartScreenMusicIfNeeded);
    document.addEventListener('touchstart', playStartScreenMusicIfNeeded);
    document.addEventListener('keydown', playStartScreenMusicIfNeeded);

    // Add mute/unmute button
    const muteButton = document.createElement('button');
    muteButton.id = 'mute-button';
    muteButton.innerHTML = '🔊';
    muteButton.style.position = 'absolute';
    muteButton.style.top = '10px';
    muteButton.style.right = '10px';
    muteButton.style.zIndex = '1000';
    muteButton.style.background = 'rgba(0, 0, 0, 0.5)';
    muteButton.style.color = 'white';
    muteButton.style.border = 'none';
    muteButton.style.borderRadius = '5px';
    muteButton.style.padding = '5px 10px';
    muteButton.style.cursor = 'pointer';
    
    muteButton.addEventListener('click', function() {
      musicEnabled = !musicEnabled;
      
      if (musicEnabled) {
        muteButton.innerHTML = '🔊';
        // Resume music based on current game state
        if (gameOver) {
          // Check if we're on a victory screen
          const isVictoryScreen = document.querySelector('#game-over img.victory') !== null;
          if (isVictoryScreen) {
            playBackgroundMusic('winningMusic');
          } else {
            playBackgroundMusic('gameOverMusic');
          }
        } else if (gameActive) {
          // Resume appropriate audio for ice level or regular gameplay
          if (inCryptoWinter && cryptoWinterWindAudio) {
            cryptoWinterWindAudio.play().catch(e => console.log("Wind audio resume error:", e));
          } else if (inCryptoWinter && greenCandleAudio) {
            greenCandleAudio.play().catch(e => console.log("Green candle audio resume error:", e));
          } else {
            playGameplayMusic();
          }
        } else {
          playBackgroundMusic('menuMusic');
        }
      } else {
        muteButton.innerHTML = '🔇';
        stopBackgroundMusic();
        // Also stop all ice level audio
        if (cryptoWinterAudio) {
          cryptoWinterAudio.pause();
        }
        if (cryptoWinterWindAudio) {
          cryptoWinterWindAudio.pause();
        }
        if (greenCandleAudio) {
          greenCandleAudio.pause();
        }
      }
    });
    
    document.body.appendChild(muteButton);

    // Explicit audio play function with forced user gesture
    function forcePlayAudio(audioElement) {
      // Create and trigger a fake user gesture event
      const userEvent = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
      });
      
      document.dispatchEvent(userEvent);
      
      // Now try to play the audio
      console.log("Attempting to play audio with forced user gesture");
      const playPromise = audioElement.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => {
          console.error("Audio play failed despite user gesture:", error);
        });
      }
    }
    
    // Create fade-to-video transition
    function startFadeToVideo() {
      // Don't start fade if video has already played or game is over
      if (videoHasPlayed || gameOver) {
        console.log("Video has already played or game is over, not starting fade");
        return;
      }
      
      console.log("🌙 Starting fade transition to video");
      
      // First fade to black
      fadeOverlay.style.opacity = '1';
      
      // Slow down the gameplay
      backgroundSpeed = 0.5;
      
      // After fade is complete, play the video
      setTimeout(() => {
        playEndingVideo();
      }, 2000);
    }

    // Resize handler for responsive gameplay
    window.addEventListener('resize', function() {
      // Update camera
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix();
      
      // Update renderer size
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Update background dimensions with proper aspect ratio
      updateBackgroundAspectRatio();
      
      // Update player size and position for responsive design
      const playerSizeObj = getPlayerSize();
      player.scale.set(playerSizeObj.width, playerSizeObj.height, 1);
      player.width = playerSizeObj.width;
      player.height = playerSizeObj.height;
      
      // Update player position
      const playerXPosition = getPlayerXPosition();
      if (!gameActive) {
        // Only update X position if game is not active
        playerContainer.position.x = playerXPosition;
      }

      // Update game controls for different devices
      updateGameControls();
    });

    // Update the flap strength based on device
    function updateGameControls() {
      // Set flap strength based on device
      if (isMobilePortrait()) {
        flapStrength = mobileFlapStrength;
      } else {
        flapStrength = desktopFlapStrength;
      }
    }

    // Call this when game initializes
    updateGameControls();

    // Function to ensure backgrounds maintain proper aspect ratio
    function updateBackgroundAspectRatio() {
      calculateBackgroundDimensions();
      
      // Update all background sprites with new dimensions
      for (let i = 0; i < backgrounds.length; i++) {
        backgrounds[i].scale.set(backgroundWidth, backgroundHeight, 1);
      }
    }

    // Helper function for gameplay music selection
    function playGameplayMusic() {
      // Optionally randomize the starting track
      // currentGameMusicTrack = Math.floor(Math.random() * totalGameMusicTracks) + 1;
      
      playBackgroundMusic('gameMusic');
    }
  </script>

  <!-- Add Supabase JS Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // Initialize Supabase client
    const supabaseUrl = 'https://ifrwclanzakctzlaiucm.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlmcndjbGFuemFrY3R6bGFpdWNtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDczMTQzMTgsImV4cCI6MjA2Mjg5MDMxOH0.orCkZ5pLt1La6PBlUAZ8gdyBcM2ieU9K-F_U_zuYMv4';
    const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
    
    // Enhanced player analytics
    let gameStartTimestamp = 0;
    let sessionHeartbeatInterval = null;

    // Generate or retrieve unique player ID
    function getOrCreatePlayerId() {
      let playerId = localStorage.getItem('bitcoin_pizza_player_id');
      if (!playerId) {
        // Generate a random ID if not exists
        playerId = 'player_' + Math.random().toString(36).substring(2, 15);
        localStorage.setItem('bitcoin_pizza_player_id', playerId);
      }
      return playerId;
    }

    // Days between two dates helper
    function daysBetween(date1, date2) {
      return Math.floor((date2 - date1) / (1000 * 60 * 60 * 24));
    }

    // Initialize analytics system with session tracking
    function initializeAnalytics() {
      // Player identification
      const playerId = getOrCreatePlayerId();
      
      // Session management
      const sessionId = 'session_' + Math.random().toString(36).substring(2, 15);
      const currentDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
      
      // Track session start
      const lastSessionDate = localStorage.getItem('last_session_date');
      const firstSessionDate = localStorage.getItem('first_session_date') || currentDate;
      
      // Store first session date if new player
      if (!localStorage.getItem('first_session_date')) {
        localStorage.setItem('first_session_date', currentDate);
      }
      
      // Determine if this is a returning user
      const isNewDaySession = lastSessionDate !== currentDate;
      
      // Update session data
      localStorage.setItem('last_session_date', currentDate);
      
      // Track daily active user
      if (isNewDaySession) {
        const sessionsToday = parseInt(localStorage.getItem(`sessions_${currentDate}`) || '0');
        localStorage.setItem(`sessions_${currentDate}`, sessionsToday + 1);
      }
      
      // Calculate retention days if returning
      if (lastSessionDate && lastSessionDate !== currentDate) {
        const daysSinceFirstSession = daysBetween(new Date(firstSessionDate), new Date(currentDate));
        
        // Track retention milestones
        if (daysSinceFirstSession === 1 || daysSinceFirstSession === 7 || daysSinceFirstSession === 30) {
          trackGameEvent('retention', { 
            player_id: playerId,
            days_since_first: daysSinceFirstSession,
            retention_milestone: `day_${daysSinceFirstSession}`
          });
        }
      }
      
      // Track session start
      trackGameEvent('session_start', {
        player_id: playerId,
        session_id: sessionId,
        is_new_day: isNewDaySession,
        days_since_first_session: lastSessionDate ? 
          daysBetween(new Date(firstSessionDate), new Date(currentDate)) : 0
      });
      
      // Store session ID for the duration of this session
      sessionStorage.setItem('current_session_id', sessionId);
      
      // Setup heartbeat tracking for session length
      setupSessionHeartbeat();
      
      // Return session details
      return {
        playerId,
        sessionId,
        isNewDaySession
      };
    }

    // Track scene transitions
    function trackSceneTransition(fromBackground, toBackground) {
      const playerId = getOrCreatePlayerId();
      const sessionId = sessionStorage.getItem('current_session_id');
      
      trackGameEvent('scene_transition', {
        player_id: playerId,
        session_id: sessionId,
        from_scene: fromBackground,
        to_scene: toBackground
      });
    }

    // Track heartbeat for longer sessions
    function setupSessionHeartbeat() {
      // Clear any existing interval
      if (sessionHeartbeatInterval) {
        clearInterval(sessionHeartbeatInterval);
      }
      
      // Send heartbeat every minute to track session length
      sessionHeartbeatInterval = setInterval(() => {
        if (gameActive) {
          const playerId = getOrCreatePlayerId();
          const sessionId = sessionStorage.getItem('current_session_id');
          const currentDuration = Math.floor((Date.now() - gameStartTimestamp) / 1000);
          
          trackGameEvent('session_heartbeat', {
            player_id: playerId,
            session_id: sessionId,
            current_duration: currentDuration,
            current_scene: currentBackgroundIndex,
            score: Math.floor(score)
          });
        }
      }, 60000); // Every minute
    }

    // Track session end
    function trackSessionEnd() {
      const playerId = getOrCreatePlayerId();
      const sessionId = sessionStorage.getItem('current_session_id');
      if (sessionId) {
        const sessionDuration = Math.floor((Date.now() - gameStartTimestamp) / 1000);
        trackGameEvent('session_end', {
          player_id: playerId,
          session_id: sessionId,
          duration_seconds: sessionDuration
        });
      }
    }

    // Override the original savePlayerScore function
    const originalSavePlayerScore = savePlayerScore;
    
    // Save player score to Supabase
    savePlayerScore = async function() {
      let playerName = document.getElementById('player-name-input').value.trim() || 'Anon';
      
      // Strip any HTML tags and limit length
      playerName = sanitizeHTML(playerName).substring(0, 30);
      
      // If name becomes empty after sanitization, use default
      if (!playerName || playerName.length === 0) {
        playerName = 'Anon';
      }
      
      const finalScore = parseInt(localStorage.getItem('tempScore') || '0');
      const playerId = getOrCreatePlayerId();
      
      // Stop heartbeats and complete session
      stopHeartbeat();
      await completeGameSession();
      
      // Calculate verified duration from heartbeats
      const verifiedDuration = heartbeatCount * 10; // 10 seconds per heartbeat
      const clientDuration = Math.floor((Date.now() - gameStartTimestamp) / 1000);
      
      console.log(`Saving score for ${playerName}: ${finalScore}`);
      console.log(`💓 Heartbeats: ${heartbeatCount}`);
      console.log(`✅ Verified duration: ${verifiedDuration}s`);
      console.log(`📱 Client duration: ${clientDuration}s`);
      
      // Validation check - warn if no session
      if (!currentSessionId) {
        console.warn("⚠️ No session ID - score may be rejected");
      }
      
      try {
        // Save to Supabase with verified heartbeat data
        const { data, error } = await supabaseClient
          .from('leaderboard')
          .insert([
            { 
              player_name: playerName, 
              score: finalScore,
              session_duration: verifiedDuration,  // Use verified duration from heartbeats
              session_start: new Date(gameStartTimestamp).toISOString(),
              session_id: currentSessionId,
              heartbeat_count: heartbeatCount
            }
          ]);
          
        if (error) {
          console.error("Supabase error:", error);
          throw error;
        }
        
        console.log("Score saved successfully to Supabase");
        
        // Hide the name input form after saving
        document.getElementById('player-name-form').style.display = 'none';
        
        // Display updated leaderboard with the new score
        fetchAndDisplayLeaderboard(playerName, finalScore);
        
        // Also track this as a game statistic
        trackGameEvent('score_saved', { 
          player_name: playerName, 
          score: finalScore,
          player_id: playerId
        });
      } catch (err) {
        console.error("Error saving to Supabase, falling back to localStorage:", err);
        // Fallback to original localStorage implementation
        originalSavePlayerScore.call(this, playerName, finalScore);
      }
    };
    
    // New function to fetch and display leaderboard from Supabase
    async function fetchAndDisplayLeaderboard(highlightName = null, highlightScore = null) {
      console.log("Fetching leaderboard from Supabase...");
      
      try {
        // Fetch top 5 scores from Supabase
        const { data: leaderboard, error } = await supabaseClient
          .from('leaderboard')
          .select('player_name, score')
          .order('score', { ascending: false })
          .limit(5);
        
        if (error) {
          console.error("Supabase fetch error:", error);
          throw error;
        }
        
        console.log("Leaderboard data from Supabase:", leaderboard);
        
        // Update display
        const list = document.getElementById('leaderboard-list');
        list.innerHTML = ''; // Clear previous entries
        
        if (!leaderboard || leaderboard.length === 0) {
          console.log("No leaderboard data, showing placeholders");
          // If no scores yet, show placeholders
          for (let i = 0; i < 5; i++) {
            const li = document.createElement('li');
            li.innerHTML = `
              <span class="rank">#${i + 1}</span>
              <span class="name">---</span>
              <span class="score">0</span>
            `;
            list.appendChild(li);
          }
          return;
        }
        
        // Add each entry to the list
        leaderboard.forEach((entry, index) => {
          const li = document.createElement('li');
          li.innerHTML = `
            <span class="rank">#${index + 1}</span>
            <span class="name">${sanitizeHTML(entry.player_name)}</span>
            <span class="score">${entry.score}</span>
          `;
          
          // Highlight the new score if it matches
          if (highlightName && entry.player_name === highlightName && entry.score === highlightScore) {
            li.classList.add('highlight');
          }
          
          list.appendChild(li);
        });
        
      } catch (err) {
        console.error("Error with Supabase leaderboard, using localStorage instead:", err);
        // Fall back to original localStorage method
        console.log("Falling back to local leaderboard display");
        if (window.updateLeaderboard && window.displayLeaderboard) {
          if (highlightName && highlightScore) {
            updateLeaderboard(highlightName, highlightScore);
          } else {
            displayLeaderboard();
          }
        }
      }
    }
    
    // Override displayLeaderboard to use Supabase
    const originalDisplayLeaderboard = displayLeaderboard;
    displayLeaderboard = function(highlightName, highlightScore) {
      fetchAndDisplayLeaderboard(highlightName, highlightScore);
    };
    
    // Game statistics tracking function
    async function trackGameEvent(eventType, data = {}) {
      // Add player_id to all events if not already present
      if (!data.player_id) {
        data.player_id = getOrCreatePlayerId();
      }
      
      console.log(`Tracking event: ${eventType}`, data);
      
      try {
        const { error } = await supabaseClient
          .from('game_stats')
          .insert([{
            event_type: eventType,
            data: data
          }]);
          
        if (error) console.error("Error tracking event:", error);
      } catch (err) {
        console.error("Error tracking game event:", err);
      }
    }
    
    // Enhanced game start tracking
    const originalStartGame = startGame;
    startGame = function() {
      // Track session start time
      gameStartTimestamp = Date.now();
      
      // Initialize analytics on first game start if not already done
      const analytics = initializeAnalytics();
      
      trackGameEvent('game_start', {
        player_id: analytics.playerId,
        session_id: analytics.sessionId,
        current_scene: currentBackgroundIndex
      });
      
      originalStartGame.apply(this, arguments);
    };
    
    // Enhanced game end tracking
    const originalEndGame = endGame;
    endGame = function(forceGameOver, isVictory) {
      if (gameOver || forceGameOver || retryCount <= 0) {
        const playerId = getOrCreatePlayerId();
        const sessionId = sessionStorage.getItem('current_session_id');
        const gameEndTimestamp = Date.now();
        const durationSeconds = Math.floor((gameEndTimestamp - gameStartTimestamp) / 1000);
        
        // Track progress through backgrounds
        const maxBackgroundReached = Math.max(
          parseInt(localStorage.getItem('max_background_reached') || '0'),
          currentBackgroundIndex
        );
        localStorage.setItem('max_background_reached', maxBackgroundReached);
        
        const completionPercentage = ((currentBackgroundIndex + 1) / backgroundFiles.length) * 100;
        
        trackGameEvent('game_end', {
          player_id: playerId,
          session_id: sessionId,
          score: Math.floor(score), 
          victory: isVictory || false,
          duration_seconds: durationSeconds,
          max_background: currentBackgroundIndex,
          completion_percentage: completionPercentage.toFixed(2),
          backgrounds_total: backgroundFiles.length
        });
      }
      originalEndGame.apply(this, arguments);
    };
    
    // Track URL clicks
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('a[href]').forEach(link => {
        link.addEventListener('click', function() {
          const url = this.getAttribute('href');
          const playerId = getOrCreatePlayerId();
          trackGameEvent('url_click', { 
            url: url,
            player_id: playerId
          });
        });
      });
      
      // Initialize analytics on page load
      document.addEventListener('click', function initOnce() {
        initializeAnalytics();
        document.removeEventListener('click', initOnce);
      }, { once: true });
      
      // Add window unload handler to track session end
      window.addEventListener('beforeunload', function() {
        trackSessionEnd();
        // Clear heartbeat interval
        if (sessionHeartbeatInterval) {
          clearInterval(sessionHeartbeatInterval);
        }
      });
    });
    
    // Add scene transition tracking
    const originalCheckBackgroundVisibility = checkBackgroundVisibility;
    checkBackgroundVisibility = function() {
      // Store previous background index
      const previousBackgroundIndex = currentBackgroundIndex;
      
      // Call the original function
      const result = originalCheckBackgroundVisibility.apply(this, arguments);
      
      // If the background changed, track the transition
      if (previousBackgroundIndex !== currentBackgroundIndex) {
        console.log(`Background transition: ${previousBackgroundIndex} -> ${currentBackgroundIndex}`);
        trackSceneTransition(previousBackgroundIndex, currentBackgroundIndex);
      }
      
      return result;
    };
    
    // Test the connection immediately
    (async function testSupabaseConnection() {
      console.log("Testing Supabase connection...");
      try {
        const { data, error } = await supabaseClient
          .from('leaderboard')
          .select('count')
          .limit(1);
          
        if (error) {
          console.error("❌ Supabase connection test failed:", error);
        } else {
          console.log("✅ Supabase connection successful!");
        }
      } catch(e) {
        console.error("❌ Supabase connection test exception:", e);
      }
    })();
  </script>
</body>
</html>